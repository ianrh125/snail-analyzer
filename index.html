<head><base target="_blank">
    <link rel="shortcut icon" href="#">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
    html{
        box-sizing: border-box;
    }

    *, *:before, *:after {
        box-sizing: inherit;
    }
    /* changing font for all text */
    body{
        font-family: Arial, Helvetica, sans-serif;
    }
    /* establishing types for different kinds of text used*/
    .title{
        font-weight: bold;
        margin: 0px; /* altering text spacing */
    }
    .prompt{
        color: blue;
        margin-top: 10px;
        margin-bottom: 5px;
    }
    .result-text{
        display: inline-block; /* allows this and result to display in one line */
        margin: 0px;
    }
    .result-number{
        font-weight: bold;
        margin: 0px;
        display: inline-block;
    }
    /* display box for calculators */
    .calculator{
        background-color: #EEEEEE;
        border: 2px solid black;
        border-radius: 10px; /* round corners */
        padding: 10px; /* giving text room */
        margin: 10px; /* spacing calculators apart */
        width: 500px; /* change if needed,  */
        /*display: inline-block; /* let them show side by side */
    }
    /* display box for calculators */
    .analyzer{
        background-color: #EEEEEE;
        border: 2px solid black;
        border-radius: 10px; /* round corners */
        padding: 10px; /* giving text room */
        /*margin: 8px;*/ /* spacing calculators apart */
        margin-right:15px;
        margin-bottom:15px;
        width: 500px; /* change if needed,  */
        max-width: 100%;
        float:left;
        /*display: inline-block; /* let them show side by side */
    }
    .result-box{
        border: 1px solid black;
        background-color: white;
        padding: 5px;
    }
    /* tables to display the results for multiple spells, lands, and mana colors */
    table {
        border: 2px solid rgb(80 80 80);
        border-collapse: collapse;
        border-spacing: 0;
        width: 100%;
        margin-top: 8px;
    }
    th {
        border: 1px solid rgb(120 120 120);
        background-color: #ddd;
        padding-top: 3px;
        padding-bottom: 3px;
        padding-left: 5px;
        padding-right: 5px;
    }
    td {
        border: 1px solid rgb(160 160 160);
        padding-top: 2px;
        padding-bottom: 2px;
        padding-left: 5px;
        padding-right: 5px;
    }
    .table-num{
        margin: 0px;
        text-align: center;
    }
    .table-num-green{
        text-shadow: 0 0 8px #8f8;
        margin: 0px;
        text-align: center;
    }
    .table-num-yellow{
        text-shadow: 0 0 8px #ff9;
        margin: 0px;
        text-align: center;
    }
    .table-num-orange{
        text-shadow: 0 0 8px #fa5;
        margin: 0px;
        text-align: center;
    }
    .table-num-red{
        text-shadow: 0 0 8px #f55;
        margin: 0px;
        text-align: center;
    }
    .error-text{
        color: red;
    }
    .info-box{
        width: 800px;
        border: 0.5px solid black;
        background-color: #EEEEEE;
        padding: 10px; /* giving text room */
        margin: 5px;
    }
    .angry-title{
        color: red;
        font-weight: bold;
        margin: 0px; /* altering text spacing */
    }
    /* Table with tabs to switch between multiple different tables in the same output box */
    .tab-table{
        border-top: none;
        margin-top: 0px;
        margin-bottom: 8px;
    }
    .tab {
        overflow: hidden;
        /*border: 1px solid #ccc;*/
        border:none;
        background-color: #f1f1f1;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        border-bottom: none;
        /*margin-top: 8px;*/
    }

    /* Style the buttons inside the tab */
    .tab button {
        background-color: inherit;
        float: left;
        border: 1px solid black;
        border-bottom: none;
        outline: none;
        cursor: pointer;
        padding: 3px 7px;
        transition: 0.3s;
        font-size: 15px;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
    }

    /* Change background color of buttons on hover */
    .tab button:hover {
        background-color: #ccc;
    }

    /* Create an active/current tablink class */
    .tab button.active {
        background-color: #ddd;
    }

    /* Style the tab content */
    .tabcontent {
        display: none;
        padding: 6px 12px;
        border: 1px solid #ccc;
        border-top: none;
    }

    /* Avoid overflow on mobile */
    textarea{
        max-width: 100%;
    }

    select{
        max-width: 100%;
    }

    /* Big clicky buttons */
    input[type=button]{
        background-color:#77ee77;
        border-radius: 15px;
        border: 1px solid #383;
        cursor: pointer;
        padding: 5px 15px;
        font-size: 15px;
        font-weight: bold;
        box-shadow: 0 3px #383;
        transition: 0.3s ease-out;
    }
    input[type=button]:hover{
        background-color:#3e3;
    }
    input[type=button]:active{
        background-color:#5c5;
        box-shadow: 0 1px #383;
        transform: translateY(2px);
        transition: 0.07s ease-out;
    }
    input[type=button]:disabled{
        background-color:#bdb;
        box-shadow: 0 1px #9b9;
        transform: translateY(2px);
    }

    /* Hide commander weight drop-downs until user enters a commander*/
    .commander-name{
        margin: 1px;
    }
    .commander-name:placeholder-shown + .commander-weight{
        display:none;
    }
    .commander-weight {
        display: block;
    }

    </style>
</head>
<body onload="disableButton()">
    <script>
    var testDict; // map of loaded cards

    var landTypes; // array of 32 integers, counting the number of lands producing each subset of the 5 colors
    var landCount; // number of lands in deck
    var iterations; // global count of iterations of recursive functions
    var deckList; // array of cards in deck
    var deckSize; // number of cards in deck
    var loadCount = 0; // number of times the deck loader has been used

    var oneDropDict; // map of mana costs to cast statistics for spells with cmc 1
    var twoDropDict; // map of mana costs to cast statistics for spells with cmc 2
    var threeDropDict; // map of mana costs to cast statistics for spells with cmc 3
    var fourDropDict; // map of mana costs to cast statistics for spells with cmc 4
    var manaDict; // map of mana costs to cast statistics for spells with cmc 5+

    var mullLands; // distribution of lands in hand after implementing Frank Karsten's mulligan policy

    var white; // number of white symbols in costs
    var blue; // number of blue symbols in costs
    var black; // number of black symbols in costs
    var red; // number of red symbols in costs
    var green; // number of green symbols in costs

    var approxColors; // number of colors at which to use a limited number of samples instead of every combination of lands
    var approxSamples; // number of samples to use
    var deckColors; // number of different colors of mana in the deck

    var commander1; // card data for a deck's Commander
    var commander2; // card data for a deck's partner/background
    var commander3; // card data for a deck's companion

    var lastDecklist; // Last decklist sent to the server, make sure it isn't loaded twice

    var plainsTypes; // types found on lands that also have plains as a type
    var islandTypes; // types found on lands that also have plains as a type
    var swampTypes; // types found on lands that also have plains as a type
    var mountainTypes; // types found on lands that also have plains as a type
    var forestTypes; // types found on lands that also have plains as a type

    var condLands; // tracking lands like tainted or verge lands
    var condNames;
    var lastLandTurn; // assuming a player starts with 7 cards and draws 1 card a turn, how many lands can they play before missing a land drop?

    var ignoreCards; // list of cards to be ignored from analysis
    var roundWUBRG = [];
    var landAdded;

    var roundTime;
    // staples to automatically discount
    const commonDiscounts = {
        "Blasphemous Act": 5,
        "The Great Henge": 4,
        "Treasure Cruise": 4,
        "Ghalta, Primal Hunger": 6,
        "Dig Through Time": 4,
        "City On Fire": 2,
        "Hour of Reckoning": 3,
        "Vanquish the Horde": 4,
        "Thoughtcast": 2,
        "Thought Monitor": 3,
        "The Skullspore Nexus": 4,
        "Organic Extinction": 4,
        "Hoarding Broodlord": 3,
        "Metalwork Colossus": 6,
        "Excalibur, Sword of Eden": 7
    }

    // Basic factorial function
    function fact(x){
        let y = x
        while(x>2){
            x=x-1
            y=y*x
        }
        if(y==0){y=y+1}
        return y
    }

    // In cases where we have x!/y! and x>y, it is effectively equal to (y+1)(y+2)(y+3)...(x-2)(x-1)x
    // So we could save a lot of computation by simply calculating it as such
    function partialFact(y, x){
        let z = 1;
        while(x > y && x > 1){
            z = z * x;
            x = x - 1;
        }
        if(z==0){z=z+1}
        return z;
    }

    // Revised implementation of the choose operation
    // Cancel out certain factorial values in the numerator and denominator using partialFact
    function quickChoose(x, y){
        let z = partialFact(Math.max(y, x-y), x)/fact(Math.min(y, x-y));
        return z;
    }

    // Basic sum function
    function sum(arr){
        return arr.reduce((a, b) => a + b, 0);
    }

    // Implementation of a hypergeometric PMF
    // Given deck size, type count, draw size, and quota, calculates the chance of drawing exactly the quota of that type
    function drawType(allTotal, typeTotal, allDrawn, typeDrawn){
        let x = quickChoose(allTotal-typeTotal, allDrawn-typeDrawn)*quickChoose(typeTotal, typeDrawn)/quickChoose(allTotal, allDrawn);
        return x;
    }

    // Given deck size, type count, draw size, and type quota, run drawType for every amount >= quota and sum results
    function drawTypeMin(allTotal, typeTotal, allDrawn, typeDrawn){
        let x = 0;
        for(let i = typeDrawn; i <= allDrawn && i <= typeTotal; i++){
            x += drawType(allTotal, typeTotal, allDrawn, i);
        }
        return x;
    }

    // Given deck size, 2 type counts, draw size, and 2 type quotas, find chance of meeting both quotas
    // Walks through all satisfactory amounts of first type, and uses drawTypeMin to see if second type will meet quota
    // Multiplies the two together to get the intersecting probability, and returns the sum
    // Since we already accounted for the number of type A being drawn, the second calculation is run with all type A removed from the deck
    function drawTwoTypeMin(allTotal, totalA, totalB, allDrawn, drawnA, drawnB){
        let x = 0;
        for(let i = drawnA; i <= allDrawn && i <= totalA; i++){
            x += drawType(allTotal, totalA, allDrawn, i)*drawTypeMin(allTotal-totalA, totalB, allDrawn-i, drawnB);
        }
        return x;
    }

    // Converts the color costs of a card into an int from 0-31 representing 5 boolean values
    // white=1, blue=2, black=4, red=8, green=16
    function processCost(cost){
        return Math.sign(cost.w + cost.wu + cost.wb + cost.wr + cost.wg)
            + 2 * Math.sign(cost.u + cost.wu + cost.ub + cost.ur + cost.ug)
            + 4 * Math.sign(cost.b + cost.wb + cost.ub + cost.br + cost.bg)
            + 8 * Math.sign(cost.r + cost.wr + cost.ur + cost.br + cost.rg)
            + 16 * Math.sign(cost.g + cost.wg + cost.ug + cost.bg + cost.rg);
    }

    // Count the number of colors in a card's mana cost
    function numColors(cost){
        return Math.sign(cost.w) + Math.sign(cost.u) + Math.sign(cost.b) + Math.sign(cost.r) + Math.sign(cost.g);
    }

    // Extract the colored pips from a color cost
    function colorReqs(cost){
        return {
            w: cost.w,
            u: cost.u,
            b: cost.b,
            r: cost.r,
            g: cost.g,
            wu: cost.wu,
            wb: cost.wb,
            wr: cost.wr,
            wg: cost.wg,
            ub: cost.ub,
            ur: cost.ur,
            ug: cost.ug,
            br: cost.br,
            bg: cost.bg,
            rg: cost.rg
        };
    }

    // Encode the color pips of a mana cost as an integer using prime factors
    // Allows us to use the color pips of spells as a map key
    function pipsToNum(cost){
        return 2 ** cost.w * 3 ** cost.u * 5 ** cost.b * 7 ** cost.r * 11 ** cost.g
            * 13 ** cost.wu * 17 ** cost.wb * 19 ** cost.wr * 23 ** cost.wg * 29 ** cost.ub
            * 31 ** cost.ur * 37 ** cost.ug * 41 ** cost.br * 43 ** cost.bg * 47 ** cost.rg;
    }

    // Simplify the categories of lands to only be relevant to a given color cost
    function landFilter(myLandTypes, cost){
        let costCode = processCost(cost);
        let limitedLandTypes = new Array(32).fill(0);
        for(let i = 0; i < 32; i++){
            limitedLandTypes[i&costCode] += myLandTypes[i];
        }
        return limitedLandTypes;
    }

    // Calculate how lands contribute sources of various color combinations
    function sourcesFromLands(myLandTypes){
        let sources = new Array(32).fill(0);
        // Iterate through the 32 subsets of the 5 mana colors and find the number of sources for each
        for(let i = 0; i < 32; i++){
            // Iterate through the 32 subsets of the 5 mana colors and add the number of sources of each to the total of the relevant color combination
            for(let j = 0; j < 32; j++){
                sources[i] += myLandTypes[j] * Math.sign(j & i); //limit the colors produced to the intersection between the colors needed and the actual production
            }
        }
        return sources;
    }

    // This tool uses some approximations that represent certain sources as fractions of lands. This does not play well with our hypergeometric distributions
    // Take a land count and set of land categories that are not whole numbers, and convert them to a set of whole numbers
    // These whole numbers need to behave as closely as possible to how those fractional lands would have.
    // I am mainly trying to preserve the output on the color combination requirement array.
    // I am currently using a search function that might be a little bit expensive, but not excessively so compared to the resources used by the analysis itself
    function roundLands(myLandTypes){
        let myLandCount = sum(myLandTypes);
        let roundLandCount = Math.round(myLandCount);
        let floorLandTypes = new Array(32).fill(0);
        let floorLandCount = 0;
        let landsToRound = 0;
        // start with all lands rounded down, note how many to round back up.
        for(let i = 0; i < 32; i++){
            floorLandTypes[i] = Math.floor(myLandTypes[i]);
            floorLandCount += floorLandTypes[i];
            if(floorLandTypes[i] < myLandTypes[i]){
                landsToRound += 1;
            }
        }
        // calculate error between output of rounded down lands and output of unrounded land totals.
        let benchmark = sourcesFromLands(myLandTypes);
        let floorSources = sourcesFromLands(floorLandTypes);
        let error = new Array(32).fill(0);
        for(let i = 0; i < 32; i++){
            error[i] = floorSources[i] - benchmark[i];
        }

        let result = roundSearch(floorLandTypes.slice(), myLandTypes, roundLandCount - floorLandCount, 31, error, landsToRound);
        let searchLandTypes = result[0];
        let reportedError = result[1];

        return searchLandTypes;
    }

    // The search function for roundLands
    // It goes through the lands, and for any that are not already a whole number, it branches and searches best solutions with it rounded up and rounded down
    // Recursively calls itself for each branch to find the best combination of rounding for the remaining unrounded numbers.
    function roundSearch(myRoundLands, myLandTypes, landsToAdd, i, error, landsToRound){
        // searches for next unrounded value
        while(myLandTypes[i] <= myRoundLands[i] && i >= 0){
            i--;
        }
        if(landsToAdd < 1 || i < 0){
            // once it reaches the end of the array or runs out of extra lands to add, calculate error and return
            let sumSq = 0;
            for(let j = 0; j < 32; j++){
                sumSq += error[j] ** 2;
            }
            return [myRoundLands, sumSq + landsToAdd * 100, error];
        }
        if(landsToAdd >= landsToRound){
            let newRoundLands = myRoundLands.slice();
            newRoundLands[i] += 1;
            let newError = error.slice();
            for(let j = 0; j < 32; j++){
                newError[j] += Math.sign(j & i);
            }
            return roundSearch(newRoundLands, myLandTypes, landsToAdd - 1, i - 1, newError, landsToRound - 1);
        }
        // calculate two sets of lands, one with and without land i rounded up, run search on both of them, and return the one with less error
        let set1 = roundSearch(myRoundLands.slice(), myLandTypes, landsToAdd, i - 1, error, landsToRound - 1);
        let newRoundLands = myRoundLands.slice();
        newRoundLands[i] += 1;
        let newError = error.slice();
        for(let j = 0; j < 32; j++){
            newError[j] += Math.sign(j & i);
        }
        let set2 = roundSearch(newRoundLands, myLandTypes, landsToAdd - 1, i - 1, newError, landsToRound - 1);
        if(set1[1] > set2[1]){
            return set2;
        }
        return set1;
    }

    // Given lands with conditions like tainted or verge lands, figure out how likely the condition is to be met with a given number of lands drawn in total
    function condAdjust(drawn){
        let myLandTypes = landTypes.slice();
        let myLandCount = Math.round(landCount);
        // iterate through list of conditional lands, compute the likelihood of the condition being met, and adjust mana source count accordingly
        for(let i = 0; i < condLands.length; i++){
            let matches = typeSearch(condLands[i][2].replaceAll("a ","").replaceAll("an ","").split(" or "));
            let odds = drawTypeMin(myLandCount - 1, matches, Math.max(0, drawn - 1), 1);
            myLandTypes[condLands[i][0]] -= odds;
            myLandTypes[condLands[i][1]] += odds;
        }
        return myLandTypes;
    }

    // Given a list of card types or subtypes, search the decklist to find how many match one or more of those types
    function typeSearch(typeList){
        let numFound = 0;
        for(let i = 0; i < deckList.length; i++){
            let match = false;
            for(let j = 0; j < typeList.length && !match; j++){
                match = deckList[i].card_type.toLowerCase().includes(typeList[j].toLowerCase());
            }
            if(match){
                numFound += deckList[i].count;
            }
        }
        return numFound;
    }

    // For a given set of color pips in a mana cost, generate a cdf for when a manabase is able to afford those colors
    function pipDist(cost){
        // override empty input fields with default values
        if(approxColors == undefined){
            approxColors = 5;
        }
        if(approxSamples == undefined){
            approxSamples = 100000;
        }
        let startTime = Date.now();
        if(numColors(cost) == 5 && roundWUBRG.length == 0){
            for(let n = 0; n <= 12; n++){
                // filter and round lands for given color combination
                let roundedLands = roundLands(landFilter(condAdjust(n), cost));
                roundWUBRG.push(roundedLands);
            }
        }
        roundTime = Date.now()-startTime;

        let canCast = new Array(13);
        let comboReqs = getComboReqs(cost);
        // run 2 different versions of the analysis program, 1 that estimates for expensive cards, one that does the perfect computation for cheap cards.
        if(numColors(cost) < approxColors){
            for(let n = 0; n <= 12; n++){
                // filter and round lands for given color combination
                let roundedLands = [];
                if(numColors(cost) == 5){
                    roundedLands = roundWUBRG[n].slice();
                    for(let i = 0; i < 32; i++){
                        roundedLands[i] += landAdded[i];
                    }
                }
                else{
                    roundedLands = roundLands(landFilter(condAdjust(n), cost));
                }
                let roundedLandCount = sum(roundedLands);
                result = rLandTest(cost, roundedLands, n, roundedLandCount, 31, 1, structuredClone(comboReqs));
                canCast[n] = result;
            }
        }
        else{
            for(let n = 0; n <= 12; n++){
                // filter and round lands for given color combination
                let roundedLands = [];
                if(numColors(cost) == 5){
                    roundedLands = roundWUBRG[n].slice();
                    for(let i = 0; i < 32; i++){
                        roundedLands[i] += landAdded[i];
                    }
                }
                else{
                    roundedLands = roundLands(landFilter(condAdjust(n), cost));
                }
                let roundedLandCount = sum(roundedLands);
                result = landTestUniformSample(cost, roundedLands, n, roundedLandCount, 31, 0, approxSamples, structuredClone(comboReqs));
                canCast[n] = (result / approxSamples);
            }
        }

        return canCast;
    }
    // Calculate the distribution of # of lands in hand after the player mulligans.
    // Follows Frank Karsten's mulligan logic from his 2022 "How many sources?" article.
    function calcMullLands(){
        let myLandCount = Math.round(landCount);
        let openingDist = new Array(8);
        let mullDist = new Array(8);
        mullLands = new Array(8).fill(0);
        let mullAmount = 0;
        // distribution for a random hand
        for(let i = 0; i <= 7; i++){
            openingDist[i] = drawType(deckSize, myLandCount, 7, i);
            mullDist[i] = openingDist[i];
        }

        //free mull, shoot for at least three if deck is a commander deck
        if(deckSize >= 90){
            mullAmount = mullDist[0] + mullDist[1] + mullDist[2] + mullDist[6] + mullDist[7];
            for(let i = 3; i < 6; i++){
                mullLands[i] += mullDist[i];
            }
        }
        else{
            mullAmount = mullDist[0] + mullDist[1] + mullDist[6] + mullDist[7];
            for(let i = 2; i < 6; i++){
                mullLands[i] += mullDist[i];
            }
        }

        mullDist = new Array(8).fill(0);

        for(let i = 0; i <= 7; i++){
            mullDist[i] += openingDist[i] * mullAmount;
        }

        // Second mull, accept 2 if needed
        mullAmount = mullDist[0] + mullDist[1] + mullDist[6] + mullDist[7];
        for(let i = 2; i < 6; i++){
            mullLands[i] += mullDist[i];
        }
        mullDist = new Array(8).fill(0);

        // shoot for 3 lands with our discards
        for(let i = 0; i <= 3; i++){
            mullDist[i] += openingDist[i] * mullAmount;
        }
        for(let i = 4; i <= 7; i++){
            mullDist[i - 1] += openingDist[i] * mullAmount;
        }

        // After we discard to 6, the 6 and 7 land hands are now 5 and 6 land hands
        mullAmount = mullDist[0] + mullDist[1] + mullDist[5] + mullDist[6];
        for(let i = 2; i < 5; i++){
            mullLands[i] += mullDist[i];
        }
        mullDist = new Array(8).fill(0);

        // discard 2, once again shooting for 3 lands
        for(let i = 0; i <= 3; i++){
            mullDist[i] += openingDist[i] * mullAmount;
        }
        mullDist[3] += openingDist[4] * mullAmount;
        for(let i = 5; i <= 7; i++){
            mullDist[i - 2] += openingDist[i] * mullAmount;
        }

        // After we discard to 5, we'll settle for at least one spell
        mullAmount = mullDist[0] + mullDist[1] + mullDist[5];
        for(let i = 2; i < 5; i++){
            mullLands[i] += mullDist[i];
        }
        mullDist = new Array(8).fill(0);

        // discard to 4, 3 lands again
        for(let i = 0; i <= 3; i++){
            mullDist[i] += openingDist[i] * mullAmount;
        }
        for(let i = 4; i <= 6; i++){
            mullDist[3] += openingDist[i] * mullAmount;
        }
        mullDist[4] += openingDist[7] * mullAmount;

        for(let i = 0; i < 7; i++){
            mullLands[i] += mullDist[i];
        }
        // only keep after 4
    }

    // Find the distribution of lands drawn by a given turn, factoring in mulligans
    function landsAtTurn(turn){
        let myLandCount = Math.round(landCount);
        let landDist = new Array(13).fill(0);
        for(let startLands = 0; startLands < 7; startLands++){
            for(let drawnLands = 0; drawnLands <= turn; drawnLands++){
                landDist[Math.min(startLands + drawnLands, 12)] += mullLands[startLands] * drawType(deckSize-7, myLandCount - startLands, turn, drawnLands);
            }
        }
        return landDist;
    }

    // This is The Algorithm right here
    // Recursively testing different combinations of lands
    // Moving through the list of possible land types, if one is present in the deck, calculate the different possibilities for how many are in there.
    // Then adjust the numbers to feed back into rLandTest to account for the rest
    function rLandTest(cost, myLandTypes, numLands, myLandCount, i, scale, comboReqs){
        // check if mana requirements are already satisfied
        if(Math.max(...comboReqs) <= 0){
            return 1;
        }
        // check if mana requirements are unreachable
        if(Math.max(...comboReqs) > numLands){
            return 0;
        }
        let success = 0.0;
        let total = 0.0;
        iterations++;
        // scan forward through the land categories to find one thats in the deck
        while(i > 0 && myLandTypes[i] == 0){
            i--;
        }
        // check point of no return for each color
        if(i < 16 && comboReqs[16] > 0){
            return 0;
        }
        if(i < 8 && comboReqs[8] > 0){
            return 0;
        }
        if(i < 4 && comboReqs[4] > 0){
            return 0;
        }
        if(i < 2 && comboReqs[2] > 0){
            return 0;
        }
        // run through the different numbers of the category of land that can be drawn, test their probability and recursively check with the remaining lands of each of them.
        for(let n = 0; n <= numLands && n <= myLandTypes[i]; n++){
            let p = drawType(myLandCount, myLandTypes[i], numLands, n);
            if(p > 0){
                result = rLandTest(cost, myLandTypes, numLands - n, myLandCount - myLandTypes[i], i-1, p * scale, comboReqs.slice());
                success += p * result;
            }
            for(let j = 0; j < 32; j++){
                comboReqs[j] -= Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
            }
        }
        return success;
    }

    // Like rLandTest, but divides the probability space over a number line of a given length
    // Instead of counting the exact proportions of each probability, it counts the number of "ticks" on the line within its slice of the line
    // Thus, it will give near-perfect estimations for probabilities that are well above the line's "resolution"
    // And for probabilities that are well below it, it functions more like a random sample
    function landTestUniformSample(cost, myLandTypes, numLands, myLandCount, i, min, max, comboReqs){
        if(Math.floor(max) == Math.floor(min)){
            // no ticks in range
            return 0;
        }
        // same as rLandTest except divides up space between max and min amongst branches
        if(Math.max(...comboReqs) <= 0){
            return Math.floor(max) - Math.floor(min);
        }
        if(Math.max(...comboReqs) > numLands){
            return 0;
        }
        while(i > 0 && myLandTypes[i] == 0){
            i--;
        }
        if(i < 16 && comboReqs[16] > 0){
            return 0;
        }
        if(i < 8 && comboReqs[8] > 0){
            return 0;
        }
        if(i < 4 && comboReqs[4] > 0){
            return 0;
        }
        if(i < 2 && comboReqs[2] > 0){
            return 0;
        }
        iterations++;
        let success = 0;
        let span = max-min;
        let newMin = min;
        let newMax = min;
        let totalP = 0;
        for(let n = 0; n <= numLands && n <= myLandTypes[i]; n++){
            let p = drawType(myLandCount, myLandTypes[i], numLands, n);
            if(p > 0){
                newMin = newMax;
                newMax += p * span;
                totalP += p;
                success += landTestUniformSample(cost, myLandTypes, numLands - n, myLandCount - myLandTypes[i], i-1, newMin, newMax, comboReqs.slice());
            }
            for(let j = 0; j < 32; j++){
                comboReqs[j] -= Math.sign(j & i);
            }
        }
        return success;
    }

    // Calculates the requirements for each combination of colors
    // ex. a card costing {1}{U}{W} would require 1 blue source, 1 white source, and 2 sources that can produce either blue or white.
    function getComboReqs(cost){
        let comboReqs = new Array(32).fill(0);
        comboReqs[1] = cost.w;
        for(let i = 2; i < 4; i++){
            comboReqs[i] = comboReqs[i - 2] + cost.u + cost.wu * Math.sign(i & 1);
        }
        for(let i = 4; i < 8; i++){
            comboReqs[i] = comboReqs[i - 4] + cost.b + cost.wb * Math.sign(i & 1) + cost.ub * Math.sign(i & 2);
        }
        for(let i = 8; i < 16; i++){
            comboReqs[i] = comboReqs[i - 8] + cost.r + cost.wr * Math.sign(i & 1) + cost.ur * Math.sign(i & 2) + cost.br * Math.sign(i & 4);
        }
        for(let i = 16; i < 32; i++){
            comboReqs[i] = comboReqs[i - 16] + cost.g + cost.wg * Math.sign(i & 1) + cost.ug * Math.sign(i & 2) + cost.bg * Math.sign(i & 4) + cost.rg * Math.sign(i & 8);
        }
        return comboReqs;
    }

    // Using the stored pipdist dictionaries, get the distribution of how many lands are required to cast a spell
    function landsToCast(cost, turn){
        let pipReqs = [];
        if(cost.t == 1){
            pipReqs = oneDropDict.get(pipsToNum(cost)).slice();
        }
        else if(cost.t == 2){
            pipReqs = twoDropDict.get(pipsToNum(cost)).slice();
        }
        else if(cost.t == 3){
            pipReqs = threeDropDict.get(pipsToNum(cost)).slice();
        }
        else if(cost.t == 4){
            pipReqs = fourDropDict.get(pipsToNum(cost)).slice();
        }
        else{
            let numfromPips = pipsToNum(cost)
            pipReqs = manaDict.get(numfromPips).slice();
        }
        for(let i = 0; i < cost.t; i++){
            pipReqs[i] = 0;
        }
        return pipReqs;
    }

    // Encode a land's ability to produce each color as a boolean, stored in a 5-bit int
    // white=1, blue=2, black=4, red=8, green=16
    function findLandIndex(source){
        let landIndex = 0;
        if(source.w){
            landIndex += 1;
        }
        if(source.u){
            landIndex += 2;
        }
        if(source.b){
            landIndex += 4;
        }
        if(source.r){
            landIndex += 8;
        }
        if(source.g){
            landIndex += 16;
        }
        return landIndex
    }

    // using the distributions of how many lands are required to cast a given spell and how many are available at a given turn, find the pdf on casting a spell on turns 1-12
    function turnsToCast(cost, turn){
        let landReqs = landsToCast(cost, turn);
        let canCast = new Array(16);
        for(let i = 0; i < turn; i++){
            canCast[i] = 0;
        }
        // iterate through turns ranging from the first turn where it becomes possible to the last turn we consider
        for(let i = turn; i <= 15; i++){
            let pCast = 0;
            let landDist = landsAtTurn(i);
            for(let lands = cost.t; lands <= 12; lands++){
                pCast += landReqs[lands] * landDist[lands];
            }
            canCast[i] = pCast
        }
        let pdf = new Array(16);
        pdf[0] = canCast[0];
        for(let i = 1; i < 15; i++){
            pdf[i] = canCast[i] - canCast[i-1];
        }
        pdf[15] = 1-canCast[14];
        return pdf;
    }

    // Function to calculate the mean of a pdf
    function mean(pdf){
        let avg = 0;
        for(let i = 0; i < pdf.length; i++){
            avg += i * pdf[i];
        }
        return avg;
    }


    function getColorCost(cost){
        //
        let cc = {
            w: cost.split("{W}").length - 1,
            u: cost.split("{U}").length - 1,
            b: cost.split("{B}").length - 1,
            r: cost.split("{R}").length - 1,
            g: cost.split("{G}").length - 1,
            wu: cost.split("{W/U}").length - 1,
            wb: cost.split("{W/B}").length - 1,
            wr: cost.split("{R/W}").length - 1,
            wg: cost.split("{G/W}").length - 1,
            ub: cost.split("{U/B}").length - 1,
            ur: cost.split("{U/R}").length - 1,
            ug: cost.split("{G/U}").length - 1,
            br: cost.split("{B/R}").length - 1,
            bg: cost.split("{B/G}").length - 1,
            rg: cost.split("{R/G}").length - 1,
            x: cost.split("{X}").length - 1,
            c: parseInt(cost.substring(1, cost.length-1).split('}{')[0]) || 0
        };
        let xValue = 0;
        if(cc.x == 1){
            xValue = 3; // one X, X = 3
        }
        else if(cc.x == 2){
            xValue = 2; // 2 Xs, X = 2
        }
        else if(cc.x > 2){
            xValue = 1 // 3+ Xs X = 1
        }
        // sum
        cc.t = cc.w + cc.u + cc.b + cc.r + cc.g + cc.wu + cc.wb + cc.wr + cc.wg + cc.ub + cc.ur + cc.ug + cc.br + cc.bg + cc.rg + cc.c + (cc.x * xValue);
        return cc;

    }

    // Approximates fetch lands by breaking them down into the lands they can fetch for
    // 50% is treated as a land that can tap for whatever the fetch land can fetch for
    // 50% is treated as a random distribution of the lands that can be fetched for
    function getFetchEquivalent(source){
        let myLandTypes = new Array(32).fill(0);
        let deckColors = Math.sign(white) + Math.sign(blue) * 2 + Math.sign(black) * 4 + Math.sign(red) * 8 + Math.sign(green) * 16;
        let landIndex = findLandIndex(source) & deckColors;
        // for fetches that get basic lands, just look at the colors
        if(source.fetch == "b"){
            myLandTypes[landIndex] += 0.5;
            let colors = Math.sign(landIndex & 1) + Math.sign(landIndex & 2) + Math.sign(landIndex & 4) + Math.sign(landIndex & 8) + Math.sign(landIndex & 16);
            if(source.w && white > 0){
                myLandTypes[1] += 0.5 / colors;
            }
            if(source.u && blue > 0){
                myLandTypes[2] += 0.5 / colors;
            }
            if(source.b && black > 0){
                myLandTypes[4] += 0.5 / colors;
            }
            if(source.r && red > 0){
                myLandTypes[8] += 0.5 / colors;
            }
            if(source.g && green > 0){
                myLandTypes[16] += 0.5 / colors;
            }
        }
        // for fetches that get nonbasic lands, pay attention to what fetchable duals and triomes we have
        else if(source.fetch == "nb"){
            let colors = Math.sign(landIndex & 1) + Math.sign(landIndex & 2) + Math.sign(landIndex & 4) + Math.sign(landIndex & 8) + Math.sign(landIndex & 16);
            let canFetch = new Array(32).fill(false);
            let canFetch2 = new Array(32).fill(false);
            let myIndex = landIndex
            for(let i = 0; i < 32; i++){
                canFetch[i] = (plainsTypes[i] && source.w) || (islandTypes[i] && source.u) || (swampTypes[i] && source.b) || (mountainTypes[i] && source.r)  || (forestTypes[i] && source.g);
                if(canFetch[i]){
                    //if current options include a land that isn't part of my index, include it in my index
                    myIndex = myIndex | i;
                    //if current options include a land just like this with one less color, remove it
                    canFetch[i & 30] = canFetch[i & 30] && !(i & 1);
                    canFetch[i & 29] = canFetch[i & 29] && !(i & 2);
                    canFetch[i & 27] = canFetch[i & 27] && !(i & 4);
                    canFetch[i & 23] = canFetch[i & 23] && !(i & 8);
                    canFetch[i & 15] = canFetch[i & 15] && !(i & 16);
                }
            }
            myLandTypes[myIndex] += 0.5;
            let numOptions = sum(canFetch);
            for(let i = 0; i < 32; i++){
                if(canFetch[i]){
                    myLandTypes[i] += 0.5 / numOptions;
                }
            }
        }
        return myLandTypes;
    }

    // Pings the server with the user's decklist, unpacks and stores the result
    async function loadDict(){

        //remove previous error messages
        clearError("load-result-box");
        let ignoreList = document.getElementById("ignore");
        //ignoreList.value = "";

        // sanitize input
        L = document.getElementById('decklist').value;
        let sanitizedL = L.replace("&", "%26").replaceAll("1x", "1").replaceAll("2x", "2").replaceAll("3x", "3").replaceAll("4x", "4").replaceAll("5x", "5").replaceAll("6x", "6").replaceAll("7x", "7").replaceAll("8x", "8").replaceAll("9x", "9").replaceAll("0x", "0").replaceAll(/ \[.*\]/g, "").replaceAll(" *F*", "").replaceAll(/#.*\n/g, "\n").replaceAll("+", "PLUS");
        let splitL = sanitizedL.split("\n");
        let strippedL = "";
        let inSideboard = false;
        // remove sideboard, add custom separator string
        for(let i = 0; i < splitL.length; i++){
            if(splitL[i].toLowerCase().includes("sideboard")){
                inSideboard = true
            }
            let first = splitL[i].charAt(0);
            if(first >= '1' && first <= '9' && !inSideboard){
                strippedL = strippedL + splitL[i] + "NEXT_CARD";
            }
            if(splitL[i] == ""){
                inSideboard = false;
            }
        }
        // send request to server
        if(strippedL != lastDecklist){
            console.log('loading');
            const deckLoadButton = document.getElementById("deck-load-button");
            deckLoadButton.disabled = true;
            deckLoadButton.value = 'Loading...';
            var response = await fetch('https://api.salubrioussnail.com/?cards=' + strippedL);
            console.log('loaded');
            deckLoadButton.disabled = false;
            deckLoadButton.value = 'Load';
            testDict = await response.json();
        }
        lastDecklist = strippedL;

        cardList = strippedL.split('NEXT_CARD');
        deckList = [];
        white = 0;
        blue = 0;
        black = 0;
        red = 0;
        green = 0;
        generic = 0;
        total = 0;
        let pw = 0; // produce white, produce blue, etc.
        let pu = 0;
        let pb = 0;
        let pr = 0;
        let pg = 0;

        plainsTypes = new Array(32).fill(false);
        islandTypes = new Array(32).fill(false);
        swampTypes = new Array(32).fill(false);
        mountainTypes = new Array(32).fill(false);
        forestTypes = new Array(32).fill(false);

        landTypes = new Array(32).fill(0);
        landCount = 0;
        deckSize = 0;
        commander1 = undefined;
        commander2 = undefined;
        commander3 = undefined;
        // get commander names from input fields
        let commanderName1 = (document.getElementById('commander-name-1').value) || "nocard";
        let commanderName2 = document.getElementById('commander-name-2').value || "nocard";
        let commanderName3 = document.getElementById('commander-name-3').value || "nocard";
        let commander1found = 0;
        let commander2found = 0;
        let commander3found = 0;

        condLands = [];
        condNames = [];

        let uniqueCards = new Map(); // for decklists with multiple printings of a card, combine them into a single listing
        // read in cards from decklist, collect some preliminary information
        for(let c = 0; c < cardList.length && cardList[c] != ""; c++){
            // sanitize card names
            if(cardList[c].includes(" (")){
                cardList[c] = cardList[c].substring(0, cardList[c].indexOf(" ("));
            }
            if(cardList[c].includes(" *F*")){
                cardList[c] = cardList[c].substring(0, cardList[c].indexOf(" *F*"));
            }
            cardList[c] = cardList[c].replaceAll("%26", "&");
            let name = cardList[c];
            let cut = 0
            while(name.charAt(cut) != ' '){
                cut++;
            }
            let count = parseInt(name.substring(0,cut));
            name = name.substring(cut+1).replaceAll("PLUS", "+");
            let card = testDict[name];
            // count up colors of deck
            if(card.mana_cost){
                white += card.mana_cost.split("{W}").length - 1;
                blue += card.mana_cost.split("{U}").length - 1;
                black += card.mana_cost.split("{B}").length - 1;
                red += card.mana_cost.split("{R}").length - 1;
                green += card.mana_cost.split("{G}").length - 1;
            }
            // note basic land types
            if(card.card_type && card.card_type.includes("Land")){
                let landIndex = findLandIndex(card.mana_source);
                if(card.card_type.includes("Plains")){
                    plainsTypes[landIndex] = true;
                }
                if(card.card_type.includes("Island")){
                    islandTypes[landIndex] = true;
                }
                if(card.card_type.includes("Swamp")){
                    swampTypes[landIndex] = true;
                }
                if(card.card_type.includes("Mountain")){
                    mountainTypes[landIndex] = true;
                }
                if(card.card_type.includes("Forest")){
                    forestTypes[landIndex] = true;
                }
            }

            deckSize += count;
        }
        // check to see if deck size lines up with common formats
        if(commanderName3 != "nocard"){ // exclude companion from deck total, leave commanders in
            deckSize--;
        }
        console.log("Deck size: " + deckSize + " cards");
        if(deckSize != 100 && deckSize != 60 && deckSize != 40){
            addError("load-result-box", "Warning: This deck has " + deckSize + " cards in it. If this sounds wrong, there a few things you can do:<br>"
                + "- Make sure any commanders and companions are identified<br>"
                + "- If you exported from Moxfield using \"Copy for MTGA\", it will remove any cards that aren't on Arena. Use \"Copy for MTGO\" instead");
        }
        if(commanderName1 != "nocard"){ // remove commanders for the purposes of simulating draws
            deckSize--;
        }
        if(commanderName2 != "nocard"){
            deckSize--;
        }
        // process cards in decklist
        for(let c = 0; c < cardList.length && cardList[c] != ""; c++){
            let name = cardList[c];
            let cut = 0
            while(name.charAt(cut) != ' '){
                cut++;
            }
            let count = parseInt(name.substring(0,cut));
            name = name.substring(cut+1).replaceAll("PLUS", "+");
            let card = testDict[name];
            // Handle exceptions
            if(card == "NOT FOUND"){
                addError("load-result-box", "Error: \"" + name + "\" is not in our databse or Scryfall. This may be due to a typo");
            }
            else if(card == "FOUND"){
                addError("load-result-box", "Error: \"" + name + "\" is not in our database yet. Give us a few minutes to pull the latest data and try again");
            }
            else if(card == undefined){
                addError("load-result-box", "Error: \"" + name + "\" came back as undefined");
            }
            // check to make sure entry isn't duplicate
            else if(uniqueCards.has(name)){
                deckList[uniqueCards.get(name)].count += count;
                if(card.card_type.includes("Land")){
                    // handle fetches
                    let deckColors = Math.sign(white) + Math.sign(blue) * 2 + Math.sign(black) * 4 + Math.sign(red) * 8 + Math.sign(green) * 16;
                    if(card.mana_source.fetch){
                        // break fetch lands down into pieces of lands they fetch for and add those to their relevant catefories
                        let addLandTypes = getFetchEquivalent(card.mana_source);
                        for(let i = 0; i < 32; i++){
                            landTypes[i] += addLandTypes[i] * count;
                        }
                        landCount += count;
                    }
                    else if(card.mana_source.choose){
                        // "choose a color" type mana sources (thriving, CLB gates)
                        // 50% any color, 50% split between all relevant pairs
                        let landIndex = findLandIndex(card.mana_source) & deckColors;
                        let chooseIndex = deckColors & (~landIndex);
                        let numColors = Math.sign(chooseIndex & 1) + Math.sign(chooseIndex & 2) + Math.sign(chooseIndex & 4) + Math.sign(chooseIndex & 8) + Math.sign(chooseIndex & 16);
                        landTypes[chooseIndex | landIndex] += 0.5;
                        for(let i = 1; i < 32; i *= 2){
                            if(i & chooseIndex){
                                landTypes[i | landIndex] += 1/(2*numColors);
                            }
                        }
                        landCount += count;
                    }
                    else{
                        // normal lands
                        let landIndex = findLandIndex(card.mana_source) & deckColors;
                        landTypes[landIndex] += count;
                        landCount += count;
                    }
                    // note if land has conditions (i.e. verge lands)
                    if(card.mana_source.cond){
                        let index1 = findLandIndex(card.mana_source);
                        let index2 = findLandIndex(card.mana_source.cond.colors) | index1;
                        let condition = card.mana_source.cond.cond;
                        condLands.push([index1, index2, condition]);
                        condNames.push(name);
                        console.log([index1, index2, condition]);
                    }
                }
            }
            else{
                uniqueCards.set(name, deckList.length);
                card.name = name;
                let cost = card.mana_cost;
                let colorCost = getColorCost(cost);
                card.colorCost = colorCost;
                let sourceMult = 1;
                card.count = count;
                // check card name against common discounts
                if(commonDiscounts[name]){
                    card.discount = commonDiscounts[name];
                    if(ignoreList.value){
                        ignoreList.value += "\n";
                    }
                    ignoreList.value += card.discount + " " + name;
                }
                else{
                    card.discount = 0;
                }
                card.ignore = false;

                // checking card names against commander names
                if(card.name.toLowerCase().includes(commanderName1.toLowerCase())){
                    if(commander1found > 0){
                        deckList.push(structuredClone(commander1));
                    }
                    commander1 = card;
                    console.log("commander 1: " + card.name);
                    commander1found += 1;
                }
                else if(card.name.toLowerCase().includes(commanderName2.toLowerCase())){
                    if(commander2found > 0){
                        deckList.push(structuredClone(commander2));
                    }
                    commander2 = card;
                    console.log("commander 2: " + card.name);
                    commander2found += 1;
                }
                else if(card.name.toLowerCase().includes(commanderName3.toLowerCase())){
                    if(commander3found > 0){
                        deckList.push(structuredClone(commander3));
                    }
                    commander3 = card;
                    console.log("commander 3: " + card.name);
                    commander3found += 1;
                }
                // categorizing lands and incrementing category totals
                else if(card.card_type.includes("Land")){
                    // handle fetches
                    let deckColors = Math.sign(white) + Math.sign(blue) * 2 + Math.sign(black) * 4 + Math.sign(red) * 8 + Math.sign(green) * 16;
                    if(card.mana_source.fetch){
                        // break fetch lands down into pieces of lands they fetch for and add those to their relevant catefories
                        let addLandTypes = getFetchEquivalent(card.mana_source);
                        for(let i = 0; i < 32; i++){
                            landTypes[i] += addLandTypes[i] * count;
                        }
                        landCount += count;
                        deckList.push(card);
                    }
                    else if(card.mana_source.choose){
                        // "choose a color" type mana sources (thriving, CLB gates)
                        // 50% any color, 50% split between all relevant pairs
                        let landIndex = findLandIndex(card.mana_source) & deckColors;
                        let chooseIndex = deckColors & (~landIndex);
                        let numColors = Math.sign(chooseIndex & 1) + Math.sign(chooseIndex & 2) + Math.sign(chooseIndex & 4) + Math.sign(chooseIndex & 8) + Math.sign(chooseIndex & 16);
                        landTypes[chooseIndex | landIndex] += 0.5;
                        for(let i = 1; i < 32; i *= 2){
                            if(i & chooseIndex){
                                landTypes[i | landIndex] += 1/(2*numColors);
                            }
                        }
                        landCount += count;
                        deckList.push(card);
                    }
                    else{
                        // normal lands
                        let landIndex = findLandIndex(card.mana_source) & deckColors;
                        landTypes[landIndex] += count * sourceMult;
                        landCount += count;
                        deckList.push(card);
                    }
                    // note if land has conditions (i.e. verge lands)
                    if(card.mana_source.cond){
                        let index1 = findLandIndex(card.mana_source);
                        let index2 = findLandIndex(card.mana_source.cond.colors) | index1;
                        let condition = card.mana_source.cond.cond;
                        condLands.push([index1, index2, condition]);
                        condNames.push(name);
                        console.log([index1, index2, condition]);
                    }
                } else{
                    deckList.push(card);
                }
            }

        }
        console.log("lands: " + landCount);
        // check errors with commander recognition
        if(commanderName1 != "nocard" && commander1found == 0){
            addError("load-result-box", "Error: The name \"" + commanderName1 + "\" did not match with any of the cards in your decklist. Double check the spelling and capitalization and try again");
        }
        // if multiple cards match with the commander, go back and check for exact matches, warn user if there aren't any
        if(commander1found > 1){
            let exactMatch = (commander1.name.toLowerCase() == commanderName1.toLowerCase());
            for(let i = 0; i < deckList.length && !exactMatch; i++){
                if(deckList[i].name.toLowerCase() == commanderName1.toLowerCase()){
                    let swap = structuredClone(deckList[i]);
                    deckList[i] = structuredClone(commander1);
                    commander1 = swap;
                    exactMatch = true;
                }
            }
            if(!exactMatch){
                addError("load-result-box", "Error: The name \"" + commanderName1 + "\" matched with multiple cards in your decklist. Try entering the card's full name");
            }
        }
        // repeat for partner
        if(commanderName2 != "nocard" && commander2found == 0){
            addError("load-result-box", "Error: The name \"" + commanderName2 + "\" did not match with any of the cards in your decklist. Double check the spelling and capitalization and try again");
        }
        if(commander2found > 1){
            let exactMatch = (commander1.name.toLowerCase() == commanderName1.toLowerCase());
            for(let i = 0; i < deckList.length && !exactMatch; i++){
                if(deckList[i].name.toLowerCase() == commanderName2.toLowerCase()){
                    let swap = structuredClone(deckList[i]);
                    deckList[i] = structuredClone(commander2);
                    commander2 = swap;
                    exactMatch = true;
                }
            }
            if(!exactMatch){
                addError("load-result-box", "Error: The name \"" + commanderName2 + "\" matched with multiple cards in your decklist. Try entering the card's full name");
            }
        }
        // repeat for companion
        if(commanderName3 != "nocard" && commander3found == 0){
            addError("load-result-box", "Error: The name \"" + commanderName3 + "\" did not match with any of the cards in your decklist. Double check the spelling and capitalization and try again");
        }
        if(commander3found > 1){
            let exactMatch = (commander1.name.toLowerCase() == commanderName1.toLowerCase());
            for(let i = 0; i < deckList.length && !exactMatch; i++){
                if(deckList[i].name.toLowerCase() == commanderName3.toLowerCase()){
                    let swap = structuredClone(deckList[i]);
                    deckList[i] = structuredClone(commander2);
                    commander2 = swap;
                    exactMatch = true;
                }
            }
            if(!exactMatch){
                addError("load-result-box", "Error: The name \"" + commanderName3 + "\" matched with multiple cards in your decklist. Try entering the card's full name");
            }
        }

        // turn on estimation config options for players with 5 color decks
        deckColors = Math.sign(white) + Math.sign(blue) + Math.sign(black) + Math.sign(red) + Math.sign(green);
        if(deckColors >= 5){
            let configOptions = document.getElementById("approx-config");
            configOptions.hidden = false;
        }
        // deck is loaded, unlock compute buttons for other calculators
        let button = document.getElementById("color-compute-button");
        button.disabled = false;
        let error = button.parentElement;
        error.replaceChildren(button);
        button = document.getElementById("tap-compute-button");
        button.disabled = false;
        error = button.parentElement;
        error.replaceChildren(button);
        console.log('processed');
        let loadResult = document.getElementById("load-result");
        if(loadCount == 0){
            loadResult.innerText = "Deck loaded!";
        }
        else{
            loadResult.innerText = "Deck loaded! (" + loadCount + ")";
        }
        loadCount++;
        roundWUBRG = [];
        landAdded = new Array(32).fill(0);
    }

    // On startup, disable the compute buttons until the user loads their deck
    function disableButton(){
        let computeButton = document.getElementById("color-compute-button");
        computeButton.disabled = true;
        computeButton = document.getElementById("tap-compute-button");
        computeButton.disabled = true;
    }

    // For any error we want to display, print it to the output box
    function addError(resultBox, errorText){
        let error = document.createElement("div");
        error.innerHTML = errorText;
        error.classList.add("error-text");
        document.getElementById(resultBox).appendChild(error);
    }

    // Clear error text from a given result box
    function clearError(resultBox){
        let result = document.getElementById(resultBox);
        let i = 0;
        while(i < result.children.length){
            let child = result.children[i];
            if(child.classList.contains("error-text")){
                result.removeChild(child);
            }
            else{
                i++;
            }
        }
    }

    // Procedurally add rows to the analysis output table
    // Type: "th" for table header, "td" for table data
    function tableRow(rowData, type, rowClass){
        let newRow = document.createElement("tr");
        for(let i = 0; i < rowData.length; i++){
            let cell = document.createElement(type);
            cell.innerText = rowData[i];
            if(rowClass[i]){
                cell.classList.add(rowClass[i]);
            }
            newRow.appendChild(cell);
        }
        return newRow;
    }

    // Find all spells with a given mana value, get the cast distribution for their color pips, and put it into a map
    function xDropDict(x){
        let dict = new Map();
        for(let i = 0; i < deckList.length; i++){
            // run the numbers for cards with a relevant mana cost
            if(deckList[i].modColorCost.t - deckList[i].discount == x){
                let pips = colorReqs(deckList[i].modColorCost);
                let pipCode = pipsToNum(pips);
                if(!dict.has(pipCode)){
                    iterations = 0;
                    castDistro = pipDist(pips);
                    dict.set(pipCode, castDistro.slice());
                }
            }
            // run the numbers for cards with a relevant cycling cost
            else if(deckList[i].modManaSource.cycling != false && getColorCost(deckList[i].modManaSource.cycling.cost).t == x){
                let pips = colorReqs(getColorCost(deckList[i].modManaSource.cycling.cost));
                let pipCode = pipsToNum(pips);
                if(!dict.has(pipCode)){
                    iterations = 0;
                    castDistro = pipDist(pips);
                    dict.set(pipCode, castDistro.slice());
                }
            }
        }
        return dict;
    }

    // Find all spells of a given mana value that act as a mana source or gain one through other means
    function scanForSources(x){
        for(let i = 0; i < deckList.length; i++){
            // make sure mana value lines up
            if(deckList[i].modColorCost.t - deckList[i].discount == x && !(deckList[i].card_type.includes("//") && deckList[i].card_type.includes("Land"))){
                let landIndex = findLandIndex(deckList[i].modManaSource);
                let typeMult = 1;
                // penalize more fragile permanent types
                if(deckList[i].card_type.includes("Artifact")){
                    typeMult = 0.75;
                }
                if(deckList[i].card_type.includes("Creature")){
                    typeMult = 0.5;
                }
                // handle fetches
                if(deckList[i].modManaSource.fetch){
                    let addLandTypes = getFetchEquivalent(deckList[i].modManaSource);
                    for(let j = 0; j < 32; j++){
                        landTypes[j] += addLandTypes[j] * deckList[i].count * typeMult;
                    }
                    landCount += deckList[i].count * typeMult;
                }
                // "choose a color" type mana sources (thriving, CLB gates)
                else if(deckList[i].modManaSource.choose){
                    let deckColors = Math.sign(white) + Math.sign(blue) * 2 + Math.sign(black) * 4 + Math.sign(red) * 8 + Math.sign(green) * 16;
                    landIndex = findLandIndex(deckList[i].modManaSource) & deckColors;
                    let chooseIndex = deckColors & (~landIndex);
                    let numColors = Math.sign(chooseIndex & 1) + Math.sign(chooseIndex & 2) + Math.sign(chooseIndex & 4) + Math.sign(chooseIndex & 8) + Math.sign(chooseIndex & 16);
                    landTypes[chooseIndex | landIndex] += 0.5 * typeMult;
                    for(let j = 1; j < 32; j *= 2){
                        if(j & chooseIndex){
                            landTypes[j | landIndex] += 1/(2*numColors) * typeMult;
                        }
                    }
                    landCount += deckList[i].count * typeMult;
                }
                // handle more typical sources
                else if(landIndex != 0 || deckList[i].modManaSource.prod > 0){
                    typeMult *= turnsToCast(deckList[i].modColorCost, deckList[i].turn)[x];
                    landTypes[landIndex] += deckList[i].count * typeMult;
                    landCount += deckList[i].count * typeMult;
                }
            }
            // factor in landcycling
            else if(deckList[i].modManaSource.cycling != false && getColorCost(deckList[i].modManaSource.cycling.cost).t == x){
                if(deckList[i].modManaSource.cycling.lands != false){
                    let typeMult = turnsToCast(getColorCost(deckList[i].modManaSource.cycling.cost), 0)[x];
                    let addLandTypes = getFetchEquivalent(deckList[i].modManaSource.cycling.lands);
                    for(let j = 0; j < 32; j++){
                        landTypes[j] += addLandTypes[j] * deckList[i].count * typeMult;
                    }
                    landCount += deckList[i].count * typeMult;
                }
            }
        }
    }

    // for cards with a user-specified discount, rewrite their mana cost to reflect the discount
    function factorDiscount(colorCost, discount){
        let pips = colorCost.substring(1, colorCost.length-1).split("}{");
        let costOut = "";
        for(let i = 0; i < pips.length; i++){
            let num = parseInt(pips[i]);
            if(isNaN(num)){
                costOut += "{" + pips[i] + "}";
            }
            else{
                costOut += "{" + (num - discount) + "}";
            }
        }
        return costOut;
    }

    // batching all those little functions up into one big "run the analysis" function
    // short for Deep Analysis. Snail is aware of this abbreviation and thinks it is funny. I would not use it otherwise
    function deepAnal(individualResults){
        let textOut = "";
        manaDict = new Map();
        // simulate mulligans to get a starting distribution of lands in the opening hand
        calcMullLands();

        // calculate for one drops based on mana from lands
        oneDropDict = xDropDict(1);

        // scan one drops for mana sources
        scanForSources(1);
        // reflect newly identified sources in post-mulligan distribution
        calcMullLands();

        // calculate for two drops based on mana from lands and one drops
        twoDropDict = xDropDict(2);

        // scan two drops for mana sources
        scanForSources(2);
        calcMullLands();

        // repeat for three and four drops
        threeDropDict = xDropDict(3);
        scanForSources(3);
        calcMullLands();

        fourDropDict = xDropDict(4);
        scanForSources(4);
        calcMullLands();

        // calculate for 4 and above based on lands, 1, 2, and 3
        for(let i = 0; i < deckList.length; i++){

            let pips = colorReqs(deckList[i].modColorCost);
            let pipCode = pipsToNum(pips);
            if(!manaDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                manaDict.set(pipCode, castDistro.slice());
            }
        }
        // calculate for commanders
        if(commander1){
            let pips = colorReqs(commander1.modColorCost);
            let pipCode = pipsToNum(pips);
            if(commander1.modColorCost.t - commander1.discount == 1 && !oneDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                oneDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander1.modColorCost.t - commander1.discount == 2 && !twoDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                twoDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander1.modColorCost.t - commander1.discount == 3 && !threeDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                threeDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander1.modColorCost.t - commander1.discount == 4 && !fourDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                fourDropDict.set(pipCode, castDistro.slice());
            }
            else if(!manaDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                manaDict.set(pipCode, castDistro.slice());
            }
        }
        if(commander2){
            let pips = colorReqs(commander2.modColorCost);
            let pipCode = pipsToNum(pips);
            if(commander2.modColorCost.t - commander2.discount == 1 && !oneDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                oneDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander2.modColorCost.t - commander2.discount == 2 && !twoDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                twoDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander2.modColorCost.t - commander2.discount == 3 && !threeDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                threeDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander2.modColorCost.t - commander2.discount == 4 && !fourDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                fourDropDict.set(pipCode, castDistro.slice());
            }
            else if(!manaDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                manaDict.set(pipCode, castDistro.slice());
            }
        }
        if(commander3){
            let pips = colorReqs(commander3.modColorCost);
            let pipCode = pipsToNum(pips);
            if(commander3.modColorCost.t - commander3.discount == 1 && !oneDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                oneDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander3.modColorCost.t - commander3.discount == 2 && !twoDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                twoDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander3.modColorCost.t - commander3.discount == 3 && !threeDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                threeDropDict.set(pipCode, castDistro.slice());
            }
            else if(commander3.modColorCost.t - commander3.discount == 4 && !fourDropDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                fourDropDict.set(pipCode, castDistro.slice());
            }
            else if(!manaDict.has(pipCode)){
                iterations = 0;
                castDistro = pipDist(pips);
                manaDict.set(pipCode, castDistro.slice());
            }
        }
        // now that all of the mana values are calculated for and added to the dictionary, add up all the relevant info and return it
        let costsCovered = new Set();
        let cmcOnCurve = 0;
        let totalCmcDelay = 0;
        let totalCmc = 0;
        let allCards = new Array();
        // check how well deck can cast commanders
        if(commander1){
            let weight = document.getElementById("cmdr1-weight").selectedOptions[0].value;
            // get the distribution to afford the commander's mana cost
            let turnCastDist = turnsToCast(commander1.modColorCost, commander1.turn);
            // use it to calculate how often it's played on time, and how late it generally gets played
            let onCurveRate = turnCastDist[commander1.turn];
            let avgDelay = mean(turnCastDist) - commander1.turn;
            let cmc = Math.min(commander1.modColorCost.t, 12);
            cmcOnCurve += onCurveRate * cmc * weight;
            totalCmcDelay += avgDelay * cmc * weight;
            totalCmc += cmc * weight;
            if(!costsCovered.has(commander1.modManaCost)){
                costsCovered.add(commander1.modManaCost);
            }
            if(commander1.weight > 0){
                allCards.push([commander1.name, onCurveRate, avgDelay]);
            }
        }
        if(commander2){
            let weight = document.getElementById("cmdr2-weight").selectedOptions[0].value;
            let turnCastDist = turnsToCast(commander2.modColorCost, commander2.turn)
            let onCurveRate = turnCastDist[commander2.turn];
            let avgDelay = mean(turnCastDist) - commander2.turn;
            let cmc = Math.min(commander2.modColorCost.t, 12);
            cmcOnCurve += onCurveRate * cmc * weight;
            totalCmcDelay += avgDelay * cmc * weight;
            totalCmc += cmc * weight;
            if(!costsCovered.has(commander2.modManaCost)){
                costsCovered.add(commander2.modManaCost);
            }
            if(commander2.weight > 0){
                allCards.push([commander2.name, onCurveRate, avgDelay]);
            }
        }
        if(commander3){
            let weight = document.getElementById("cmdr3-weight").selectedOptions[0].value;
            let turnCastDist = turnsToCast(commander3.modColorCost, commander3.turn);
            let onCurveRate = turnCastDist[commander3.turn];
            let avgDelay = mean(turnCastDist) - commander3.turn;
            let cmc = Math.min(commander3.modColorCost.t, 12);
            cmcOnCurve += onCurveRate * cmc * weight;
            totalCmcDelay += avgDelay * cmc * weight;
            totalCmc += cmc * weight;
            if(!costsCovered.has(commander3.modManaCost)){
                costsCovered.add(commander3.modManaCost);
            }
            if(commander3.weight > 0){
                allCards.push([commander3.name, onCurveRate, avgDelay]);
            }
        }
        // do the same for every other card in the deck
        for(let i = 0; i < deckList.length; i++){
            if((!deckList[i].card_type.includes("Land") || (deckList[i].card_type.includes("//") && !(deckList[i].card_type == "Land // Land"))) && !deckList[i].ignore){
                let weight = deckList[i].weight;
                let turnCastDist = turnsToCast(deckList[i].modColorCost, deckList[i].turn);
                let cmc = Math.min(deckList[i].modColorCost.t, 12);
                let onCurveRate = turnCastDist[deckList[i].turn];
                let avgDelay = mean(turnCastDist) - deckList[i].turn;
                cmcOnCurve += onCurveRate * cmc * weight;
                totalCmcDelay += avgDelay * cmc * weight;
                totalCmc += cmc * weight;
                if(!costsCovered.has(deckList[i].modManaCost) && deckList[i].weight > 0){
                    costsCovered.add(deckList[i].modManaCost);
                    allCards.push([deckList[i].name, onCurveRate, avgDelay]);
                }
            }
        }
        // compute averages
        cmcOnCurve /= totalCmc;
        totalCmcDelay /= totalCmc;
        console.log("curve rate: " + cmcOnCurve);
        console.log("average delay: " + totalCmcDelay);
        if(individualResults){
            return [cmcOnCurve, totalCmcDelay, allCards];
        }
        return [cmcOnCurve, totalCmcDelay];
    }

    // Change the manabase and run the analysis again to see how that changes the results.
    function testVariant(name, landDiff, baseRate, baseDelay){
        landAdded = landDiff.slice();
        // back up global variables and make specified changes
        let landCountBackup = landCount;
        let landTypesBackup = landTypes.slice();
        for(let i = 0; i < 32; i++){
            landCount += landDiff[i];
            landTypes[i] += landDiff[i];
        }
        // run the analysis and compare results
        let analResult = deepAnal();
        let newRate = analResult[0] - baseRate;
        let newDelay = analResult[1] - baseDelay;
        let rateText;
        let delayText;
        // format them to output into tables
        if(newRate < 0){
            rateText = (newRate * 100).toFixed(2) + "%";
        }
        else{
            rateText = "+" + (newRate * 100).toFixed(2) + "%";
        }
        if(newDelay < 0){
            delayText = newDelay.toFixed(3);
        }
        else{
            delayText = "+" + newDelay.toFixed(3);
        }
        landCount = landCountBackup;
        landTypes = landTypesBackup.slice();
        return [name, rateText, delayText];
    }
    // Reformat a set of manabase changes in terms of the change to each land category
    function createDiff(indices){
        let diff = new Array(32).fill(0);
        for(let i = 0; i < indices.length; i++){
            diff[indices[i][0]] += indices[i][1];
        }
        return diff;
    }

    // Custom sort comparison for individual card table. Puts commanders at top, then sorts by highest average delay
    function cardCompare(a, b){
        if(commander1){
            if(a[0] == commander1.name){
                return -1;
            }
            if(b[0] == commander1.name){
                return 1;
            }
        }
        if(commander2){
            if(a[0] == commander2.name){
                return -1;
            }
            if(b[0] == commander2.name){
                return 1;
            }
        }
        if(commander3){
            if(a[0] == commander3.name){
                return -1;
            }
            if(b[0] == commander3.name){
                return 1;
            }
        }
        if(a[2] < b[2]){
            return 1;
        }
        if(a[2] > b[2]){
            return -1;
        }
        return 0;

    }

    // Truncate card names that are too long for the table
    function reduceName(name, maxLength){
        if(name.length > maxLength){
            let newName = name;
            while(newName.length > maxLength - 3){
                if(newName.includes(" ")){
                    newName = newName.substring(0, newName.lastIndexOf(" "));
                }
                else{
                    newName = newName.substring(0, maxLength - 3);
                }
            }
            newName = newName + "...";
            return newName;
        }
        return name;
    }

    // Remove curly braces from text representations of mana costs
    function reduceMana(mana){
        return mana.replaceAll("{W}","W").replaceAll("{U}","U").replaceAll("{B}","B").replaceAll("{R}","R").replaceAll("{G}","G")
            .replace("{1}","1").replace("{2}","2").replace("{3}","3").replace("{4}","4").replace("{5}","5")
            .replace("{6}","6").replace("{7}","7").replace("{8}","8").replace("{9}","9");
    }

    // Create a table that can toggle between multiple tables using tabs
    function createTableTab(id, parent, buttonContents, tableContents){
        // remove existing table and create our own
        let outerDiv = document.getElementById(id);
        if(outerDiv != null){
            outerDiv.remove();
        }
        outerDiv = document.createElement("div");
        outerDiv.id = id;

        let buttonDiv = document.createElement("div");
        buttonDiv.classList.add("tab");
        // set up buttons for each tab
        for(let i = 0; i < buttonContents.length; i++){
            let newButton = document.createElement("button");
            newButton.innerText=buttonContents[i];
            newButton.addEventListener('click', function(evt){switchTableTab(evt.currentTarget.id)});
            newButton.onclick="switchTableTab(" + id + ", " + i + ")";
            newButton.id = id+"-button-"+i;
            newButton.classList.add(id+"-button");
            buttonDiv.appendChild(newButton);
        }

        outerDiv.appendChild(buttonDiv);
        // set up tables and link them to buttons
        for(let i = 0; i < tableContents.length; i++){
            let newTable = tableContents[i];
            newTable.id = id+"-table-"+i;
            newTable.style.border_top = "none";
            newTable.classList.add("tab-table");
            newTable.classList.add(id+"-table");
            outerDiv.appendChild(newTable);
        }
        // insert into document, show first table
        document.getElementById(parent).appendChild(outerDiv);
        switchTableTab(id + "-button-0");
    }

    // When tab is clicked, switch to corresponding table
    function switchTableTab(buttonId){
        // find corresponding table and button
        let id = buttonId.substring(0,buttonId.indexOf("-button-"));
        let tabNum = buttonId.substring(buttonId.lastIndexOf("-")+1);
        let tables = document.getElementsByClassName(id + "-table");
        // clear existing table
        for(let i = 0; i < tables.length; i++){
            tables[i].style.display = "none";
        }

        let tablinks = document.getElementsByClassName(id + "-button");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        // show new table
        document.getElementById(id+"-table-"+tabNum).style.display = "table";
        document.getElementById(buttonId).className += " active";
    }

    function resetMods(card){
        card.modColorCost = structuredClone(card.colorCost);
        card.modManaCost = card.mana_cost;
        card.modManaSource = structuredClone(card.mana_source);
        card.weight = 1;
        card.turn = card.colorCost.t;
    }
    
    function inSelection(card, selectionText){
        if(selectionText.charAt(0)== '!'){
            return !inSelection(card, selectionText.substring(1).trim());
        }
        // check for brackets
        if(selectionText.charAt(0) == '('){
            let close = selectionText.indexOf(")");
            if(close < selectionText.length - 2){ //  there's more to it, put result in string and continue parsing
                if(inSelection(card, selectionText.substring(1, close).trim())){
                    return inSelection(card, selectionText.replace(selectionText.substring(0, close+1), "TRUE"));
                }
                return inSelection(card, selectionText.replace(selectionText.substring(0, close+1), "FALSE"));
            }
            else{
                return inSelection(card, selectionText.substring(1, close).trim());
            }
        }
        // check for quotations
        if(selectionText.charAt(0) == '"'){
            let close = selectionText.substring(1).indexOf('"') + 1;
            let matchText = selectionText.substring(1, close);
            let matchResult = card.name.toLowerCase().replace(/[^a-zA-Z0-9 ]/g, "")
                    .includes(matchText.toLowerCase().replace(/[^a-zA-Z0-9 ]/g, ""));
            
            if(close < selectionText.length - 2){ //  there's more to it, put result in string and continue parsing
                if(matchResult){
                    return inSelection(card, selectionText.replace(selectionText.substring(0, close+1), "TRUE"));
                }
                return inSelection(card, selectionText.replace(selectionText.substring(0, close+1), "FALSE"));
            }
            else{
                return matchResult;
            }
        }
        // resolve multiple selections strung together by logical operators
        if(selectionText.includes(",") || selectionText.includes("|")){
            let nextOperator = 0;
            let truthValue = false;
            selectionText = "|" + selectionText;
            while(selectionText.includes(",") || selectionText.includes("|")){
                // log current operator
                let operator = selectionText.charAt(0);
                selectionText = selectionText.substring(1);
                // find next operator
                if(selectionText.includes(",") && selectionText.includes("|")){
                    nextOperator = Math.min(selectionText.indexOf(","), selectionText.indexOf("|"));
                }
                else if(selectionText.includes(",")){
                    nextOperator = selectionText.indexOf(",");
                }
                else if(selectionText.includes("|")){
                    nextOperator = selectionText.indexOf("|");
                }
                else{
                    nextOperator = selectionText.length;
                }
                // extract and evaluate single condition
                let nextSelection = selectionText.substring(0, nextOperator).trim();
                if (operator == "|"){
                    truthValue = truthValue || inSelection(card, nextSelection);
                }
                else if(operator == ","){
                    truthValue = truthValue && inSelection(card, nextSelection);
                }
                else{
                    console.log("Unexpected operator: '" + operator + "'");
                }
                // cut condition out of selection text, continue evaluating
                selectionText = selectionText.substring(nextOperator);
            }
            return truthValue;
        }
        // evaluate specific selections
        selectionText = selectionText
            .replace(" =", "=")
            .replace("= ", "=")
            .replace("type", "t")
            .replace("mv", "m")
            .replace("cmc", "m")
            .replace("mana", "m")
            .replace("color", "c")
        if(selectionText == "TRUE"){
            return true;
        }
        if(selectionText == "FALSE"){
            return false;
        }
        if(selectionText.substring(0,2) == "t="){
            return card.card_type.toLowerCase().includes(selectionText.substring(2).toLowerCase());
        }
        if(selectionText.substring(0,2) == "m="){
            return card.modColorCost.t == parseInt(selectionText.substring(2));
        }
        if(selectionText.substring(0,3) == "m>="){
            return card.modColorCost.t >= parseInt(selectionText.substring(3));
        }
        if(selectionText.substring(0,2) == "m>"){
            return card.modColorCost.t > parseInt(selectionText.substring(2));
        }
        if(selectionText.substring(0,3) == "m<="){
            return card.modColorCost.t <= parseInt(selectionText.substring(3));
        }
        if(selectionText.substring(0,2) == "m<"){
            return card.modColorCost.t < parseInt(selectionText.substring(2));
        }
        if(selectionText.charAt(0) == "c"){
            let color = selectionText.substring(2);
            if(color.charAt(2) == '='){
                color = color.substring(1);
            }
            // create bit masks for color combinations
            let selectColorCode = 
                color.includes("w")
                + color.includes("u") * 2
                + color.includes("b") * 4
                + color.includes("r") * 8
                + color.includes("g") * 16;
            let cost = card.modColorCost
            let cardColorCode = 
                Math.min(cost.w + cost.wu + cost.wb + cost.wr + cost.wg, 1)
                + Math.min(cost.u + cost.wu + cost.ub + cost.ur + cost.ug, 1) * 2
                + Math.min(cost.b + cost.wb + cost.ub + cost.br + cost.bg, 1) * 4
                + Math.min(cost.r + cost.wr + cost.ur + cost.br + cost.rg, 1) * 8
                + Math.min(cost.g + cost.wg + cost.ug + cost.bg + cost.rg, 1) * 16;
            if(selectionText.substring(0,2) == "c="){
                // identical bit masks
                return cardColorCode == selectColorCode;
            }
            if(selectionText.substring(0,3) == "c>="){
                // no colors from outside the card's cost are in the selection
                return (~cardColorCode & selectColorCode) == 0;
            }
            if(selectionText.substring(0,2) == "c>"){
                // selection does not contain colors outside card, but card contains colors outside selection
                return ((~cardColorCode & selectColorCode) == 0 && (cardColorCode & ~selectColorCode) > 0);
            }
            if(selectionText.substring(0,3) == "c<="){
                // card contains no colors outside selection
                return (cardColorCode & ~selectColorCode) == 0;
            }
            if(selectionText.substring(0,2) == "c<"){
                // card contains no colors outside selection, but selection contains colors outside card
                return ((cardColorCode & ~selectColorCode) == 0 && (~cardColorCode & selectColorCode) > 0);
            }
        }
        
        
        return false;
    }

    function applyMod(card, modText){
        if(modText.includes(",")){
            let modList = modText.split(",");
            for(let i = 0; i < modList.length; i++){
                applyMod(card, modList[i].trim());
            }
        }
        else{
            modText = modText.replaceAll("mana=","m=").replaceAll("mana+","m+").replaceAll("mana-","m-")
                            .replaceAll("weight=","w=")
                            .replaceAll("turn=","t=").replaceAll("turn+", "t+").replaceAll("turn-", "t-");
            if(modText.includes("m=")){
                let mana = modText.substring(modText.indexOf("m=") + 2).toUpperCase();
                let properMana = "";
                for(let i = 0; i < mana.length; i++){
                    properMana += "{" + mana.charAt(i) + "}";
                }
                card.modManaCost = properMana;
                card.modColorCost = getColorCost(properMana);
                card.turn = card.modColorCost.t;
            }
            if(modText.includes("m+")){
                let mana = modText.substring(modText.indexOf("m+") + 2).toUpperCase();
                for(let i = 0; i < mana.length; i++){
                    let gAmount = parseInt(mana.charAt(i)) || 0;
                    if(mana.charAt(i) == "W"){
                        card.modColorCost.w++;
                        card.modColorCost.t++;
                    }
                    else if(mana.charAt(i) == "U"){
                        card.modColorCost.u++;
                        card.modColorCost.t++;
                    }
                    else if(mana.charAt(i) == "B"){
                        card.modColorCost.b++;
                        card.modColorCost.t++;
                    }
                    else if(mana.charAt(i) == "R"){
                        card.modColorCost.r++;
                        card.modColorCost.t++;
                    }
                    else if(mana.charAt(i) == "G"){
                        card.modColorCost.g++;
                        card.modColorCost.t++;
                    }
                    else if(gAmount > 0){
                        card.modColorCost.c += gAmount;
                        card.modColorCost.t += gAmount;
                    }
                }
                let properMana = "{" + card.modColorCost.c+ "}";
                for(let i = 0; i < card.modColorCost.w; i++){
                    properMana += "{W}";
                }
                for(let i = 0; i < card.modColorCost.u; i++){
                    properMana += "{U}";
                }
                for(let i = 0; i < card.modColorCost.b; i++){
                    properMana += "{B}";
                }
                for(let i = 0; i < card.modColorCost.r; i++){
                    properMana += "{R}";
                }
                for(let i = 0; i < card.modColorCost.g; i++){
                    properMana += "{G}";
                }
                
                card.modManaCost = properMana;
                card.turn = card.modColorCost.t;
            }
            if(modText.includes("m-")){
                let mana = modText.substring(modText.indexOf("m-") + 2).toUpperCase();
                for(let i = 0; i < mana.length; i++){
                    let gAmount = parseInt(mana.charAt(i)) || 0;
                    if(mana.charAt(i) == "W" && card.modColorCost.w > 0){
                        card.modColorCost.w--;
                        card.modColorCost.t--;
                    }
                    else if(mana.charAt(i) == "U" && card.modColorCost.u > 0){
                        card.modColorCost.u--;
                        card.modColorCost.t--;
                    }
                    else if(mana.charAt(i) == "B" && card.modColorCost.b > 0){
                        card.modColorCost.b--;
                        card.modColorCost.t--;
                    }
                    else if(mana.charAt(i) == "R" && card.modColorCost.r > 0){
                        card.modColorCost.r--;
                        card.modColorCost.t--;
                    }
                    else if(mana.charAt(i) == "G" && card.modColorCost.g > 0){
                        card.modColorCost.g--;
                        card.modColorCost.t--;
                    }
                    else if(gAmount > 0){
                        card.modColorCost.c -= Math.min(gAmount, card.modColorCost.c);
                        card.modColorCost.t -= Math.min(gAmount, card.modColorCost.c);
                    }
                }
                let properMana = "{" + card.modColorCost.c+ "}";
                for(let i = 0; i < card.modColorCost.w; i++){
                    properMana += "{W}";
                }
                for(let i = 0; i < card.modColorCost.u; i++){
                    properMana += "{U}";
                }
                for(let i = 0; i < card.modColorCost.b; i++){
                    properMana += "{B}";
                }
                for(let i = 0; i < card.modColorCost.r; i++){
                    properMana += "{R}";
                }
                for(let i = 0; i < card.modColorCost.g; i++){
                    properMana += "{G}";
                }
                
                card.modManaCost = properMana;
                card.turn = card.modColorCost.t;
            }
            if(modText.includes("w=")){
                let weight = parseFloat(modText.substring(modText.indexOf("w=") + 2));
                card.weight = weight;
            }
            if(modText.includes("t=")){
                let turn = parseInt(modText.substring(modText.indexOf("t=") + 2));
                card.turn = turn;
            }
            if(modText.includes("t+")){
                let turn = parseInt(modText.substring(modText.indexOf("t+") + 2));
                card.turn += turn;
            }
            if(modText.includes("t-")){
                let turn = parseInt(modText.substring(modText.indexOf("t-") + 2));
                card.turn -= turn;
            }
        }
        
    }

    // check selection criteria against all cards, apply mod to matching cards.
    function runMod(selectionText, modText){
        // add quotes if no quotes or selections detected
        if(!(selectionText.includes('"') || selectionText.includes("=") || selectionText.includes(">") || selectionText.includes("<"))){
            selectionText = '"' + selectionText + '"';
        }
        let cardsAffected = 0;
        for(let i = 0; i < deckList.length; i++){
            if(inSelection(deckList[i], selectionText)){
                applyMod(deckList[i], modText);
                cardsAffected++;
            }
        }
        if(commander1 && inSelection(commander1, selectionText)){
            applyMod(commander1, modText);
            cardsAffected++;
        }
        if(commander2 && inSelection(commander2, selectionText)){
            applyMod(commander2, modText);
            cardsAffected++;
        }
        if(commander3 && inSelection(commander3, selectionText)){
            applyMod(commander3, modText);
            cardsAffected++;
        }
        if(cardsAffected == 0){
            addError("modifications", "Warning: \"" + selectionText + "\" matches with 0 cards in your deck");
        }
        return;
    }

    // detect selection and mod fields of a mod and account for basic syntax errors
    function parseMod(textLine){
        // detect selection
        textLine = textLine.trim();
        let selectionText = "";
        let modText = "";
        let quoteSplit = textLine.split("\"");
        if(!textLine.includes("\"")){
            quoteSplit = "1";
        }
        if(quoteSplit.length % 2 == 0){
            addError("modifications", "Error in \"" + textLine + "\": Missing closing \"");
            return;
        }
        if(quoteSplit.length == 3){
            if(quoteSplit[0].length > 0 && quoteSplit[0].charAt(0) != "("){
                addError("modifications", "Warning: Ambiguous quotes in \"" + textLine + "\". If \""+ quoteSplit[1] +"\" is the name of the card, please remove the part before it so it can be recognized");
                textLine = textLine.replaceAll("\"", "");
                quoteSplit = "1";
            }
            else{
                selectionText = '"' + quoteSplit[1].trim() + '"';
                modText = quoteSplit[2].trim();
            }
        }
        if(quoteSplit.length > 3){
            addError("modifications", "Error in \"" + textLine + "\": Too many sets of quotes (\"). Please just use one around the name of a card");
            return;
        }
        if (quoteSplit.length == 1){
            let colonSplit = textLine.split(":");
            if (colonSplit.length == 2){
                selectionText = colonSplit[0].trim();
                modText = colonSplit[1].trim();
            }
            else if(colonSplit.length > 2){
                for(let i = 0; i < colonSplit.length - 1; i++){
                    selectionText += colonSplit[i];
                }
                selectionText = selectionText.trim();
                modText = colonSplit[colonSplit.length - 1].trim();
                addError("modifications", "Warning: multiple colons detected. Interpreting \"" + selectionText + "\" as selection and \"" + modText + "\" as modification");
            }
            else if(colonSplit.length < 2){
                addError("modifications", "Error in \"" + textLine + "\": No colon found. Please add a colon (\":\") between the selection and modification");
                return;
            }
        }
        if(selectionText.includes("(") && selectionText.split("(").length != selectionText.split(")").length){
            if(selectionText.split("(").length > selectionText.split(")").length){
                addError("modifications", "Error in \"" + selectionText + "\": Missing closing )");
            }
            if(selectionText.split("(").length < selectionText.split(")").length){
                addError("modifications", "Error in \"" + selectionText + "\": Missing opening (");
            }
            return;
        }
        runMod(selectionText, modText);
        
        // detect mod
    }

    function processMods(){
        let modifyList = document.getElementById('modify').value.split('\n');
        let modified = false;
        clearError("modifications");

        for(let i = 0; i < deckList.length; i++){
            resetMods(deckList[i]);
        }
        if(commander1){
            resetMods(commander1);
        }
        if(commander2){
            resetMods(commander2);
        }
        if(commander3){
            resetMods(commander3);
        }

        for(let i = 0; i < modifyList.length; i++){
            //console.log(modifyList[i]);
            parseMod(modifyList[i]);
        }
    }
    // This is the one tied to the compute button on the color calculator
    function colorTest(){
        // grab input from calculator
        var textType = Node.textContent ? 'textContent' : 'innerText',
        L = document.getElementById('decklist').value,
        result = document.getElementById('color-analyzer-result');

        approxColors = parseFloat(document.getElementById('approx-colors').value) || 5;
        approxSamples = parseFloat(document.getElementById('approx-samples').value) || 100000;
        let landCountBackup = landCount;
        let landTypesBackup = landTypes.slice();

        // track improvements from adding a wastes or a basic
        let genericBoost;
        let whiteBoost;
        let blueBoost;
        let blackBoost;
        let redBoost;
        let greenBoost;

        let startTime = Date.now();
        landAdded = new Array(32).fill(0);
        // reset discount and ignore status

        processMods();
        // iterate through list of ignored cards
        /*
        let ignoreListContents = document.getElementById('ignore').value.split('\n');
        let ignored = false;
        for(let i = 0; i < ignoreListContents.length; i++){
            let listItem = ignoreListContents[i];
            let cardName = "";
            let ignore = false;
            let discount = 0;
            // check for ignored cards
            if(listItem.charAt(0) == '-'){
                cardName = listItem.substring(1);
                while(cardName.charAt(0) == " "){
                    cardName = cardName.substring(1);
                }
                ignore = true;
                ignored = true;
            }
            // check for discounted cards
            else if(listItem.includes(" ")){
                cardName = listItem.substring(listItem.indexOf(" ") + 1);
                discount = parseInt(listItem.substring(0, listItem.indexOf(" ")));
            }
            if(cardName != ""){
                // go through decklist to ignore cards and apply discounts
                for(let j = 0; j < deckList.length; j++){
                    if(deckList[j].name.toLowerCase().includes(cardName.toLowerCase())){
                        console.log(cardName);
                        deckList[j].ignore = ignore;
                        if(deckList[j].colorCost.t >= discount){
                            deckList[j].discount = discount;
                        }
                        else{
                            deckList[j].discount = deckList[j].colorCost.t;
                            addError("color-analyzer-result-box", "Warning: " + cardName + " can not be given a generic discount of " + discount);
                        }
                        ignored = true;
                    }
                }
                // repeat for commanders
                if(commander1 && commander1.name.toLowerCase().includes(cardName.toLowerCase())){
                    console.log(cardName);
                    commander1.ignore = ignore;
                    if(commander1.colorCost.t >= discount){
                        commander1.discount = discount;
                    }
                    else{
                        commander1.discount = commander1.colorCost.t;
                        addError("color-analyzer-result-box", "Warning: " + cardName + " can not be given a generic discount of " + discount);
                    }
                    ignored = true;
                }
                if(commander2 && commander2.name.toLowerCase().includes(cardName.toLowerCase())){
                    console.log(cardName);
                    commander2.ignore = ignore;
                    if(commander2.colorCost.t >= discount){
                        commander2.discount = discount;
                    }
                    else{
                        commander2.discount = commander2.colorCost.t;
                        addError("color-analyzer-result-box", "Warning: " + cardName + " can not be given a generic discount of " + discount);
                    }
                    ignored = true;
                }
                if(commander3 && commander3.name.toLowerCase().includes(cardName.toLowerCase())){
                    console.log(cardName);
                    commander3.ignore = ignore;
                    if(commander3.colorCost.t >= discount){
                        commander3.discount = discount;
                    }
                    else{
                        commander3.discount = commander3.colorCost.t;
                        addError("color-analyzer-result-box", "Warning: " + cardName + " can not be given a generic discount of " + discount);
                    }
                    ignored = true;
                }
            }
        }
            for(let i = 0; i < deckList.length; i++){
            testDict[deckList[i].name].ignore = deckList[i].ignore;
            testDict[deckList[i].name].discount = deckList[i].discount;
        }

        if(ignored){
            let ignoreList = document.getElementById("ignore-list");
            ignoreList.hidden = false;
            console.log("showing ignore list");
        }
        */
       
        // reflect discount status onto stored card data for future loads
        

        //remove previous errors
        clearError("color-analyzer-result-box");

        //create a fresh table for the analysis output
        let table = document.getElementById("color-output-table");
        if(table != null){
            table.remove();
        }
        table = document.createElement("table");
        table.id = "color-output-table";
        table.appendChild(tableRow(["Manabase Variation", "Cast Rate", "Average Delay"], "th", ["","",""]));

        // run analysis on base deck
        let analResult = deepAnal(true);
        let baseRate = analResult[0];
        let baseDelay = analResult[1];
        let allCards = analResult[2];
        let rowClass = ["", "", ""];
        // color code first table
        if(baseRate >= 0.87){
            rowClass[1] = "table-num-green";
        } else if (baseRate >= 0.8){
            rowClass[1] = "table-num-yellow";
        } else if (baseRate >= 0.73){
            rowClass[1] = "table-num-orange";
        } else {
            rowClass[1] = "table-num-red";
        }
        if(baseDelay <= 0.4){
            rowClass[2] = "table-num-green";
        } else if (baseDelay <= 0.7){
            rowClass[2] = "table-num-yellow";
        } else if (baseRate <= 1){
            rowClass[2] = "table-num-orange";
        } else {
            rowClass[2] = "table-num-red";
        }
        table.appendChild(tableRow(["Current Manabase", (baseRate * 100).toFixed(1) + "%", baseDelay.toFixed(3)], "td", rowClass));

        // check to make sure repeated analyses won't run too long and freeze
        let endTime = Date.now();
        if(endTime - startTime - roundTime > 1500){
            console.log(`Execution time: ${endTime - startTime} ms`);
            document.getElementById("color-analyzer-result-box").appendChild(table);
            addError("color-analyzer-result-box", "Error: Land impact analysis cancelled, predicted runtime too high");
            landCount = landCountBackup;
            landTypes = landTypesBackup;
            return;
        }

        // remove old individual cards table, add new one
        let cardTable = document.getElementById("color-card-table");
        if(cardTable != null){
            cardTable.remove();
        }
        cardTable = document.createElement("table");
        cardTable.id = "color-card-table";
        cardTable.appendChild(tableRow(["Card Name", "Cost", "Cast Rate", "Avg. Delay"], "th", ["","","",""]));

        // sort with custom comparison, prioritize commanders then high delay cards
        allCards = allCards.sort(cardCompare);

        // add cards to individual card table and color code
        for(let i = 0; i < Math.min(allCards.length, 10); i++){
            rowClass = ["", "", "", ""];
            if(allCards[i][1] >= 0.85){
                rowClass[2] = "table-num-green";
            } else if (allCards[i][1] >= 0.75){
                rowClass[2] = "table-num-yellow";
            } else if (allCards[i][1] >= 0.65){
                rowClass[2] = "table-num-orange";
            } else {
                rowClass[2] = "table-num-red";
            }
            if(allCards[i][2] <= 0.5){
                rowClass[3] = "table-num-green";
            } else if (allCards[i][2] <= 0.8){
                rowClass[3] = "table-num-yellow";
            } else if (allCards[i][2] <= 1.2){
                rowClass[3] = "table-num-orange";
            } else {
                rowClass[3] = "table-num-red";
            }
            cardTable.appendChild(tableRow([reduceName(allCards[i][0], 25), reduceMana(factorDiscount(testDict[allCards[i][0]].modManaCost, testDict[allCards[i][0]].discount)), (allCards[i][1] * 100).toFixed(1) + "%", allCards[i][2].toFixed(3)], "td", rowClass));
        }

        landCount = landCountBackup;
        landTypes = landTypesBackup;

        // calculate for +1 wastes variant
        let wastesVariant = testVariant("+1 Wastes", createDiff([[0, 1]]), baseRate, baseDelay);
        genericBoost = -parseFloat(wastesVariant[2].substring(0,6));
        table.appendChild(tableRow(wastesVariant, "td", ["", "table-num", "table-num"]));
        let maxBoost = genericBoost;
        let maxColor = "none";
        let maxLand = "Wastes";
        // calculate for variants with all the colors present in the deck
        if(white > 0){
            let plainsVariant = testVariant("+1 Plains", createDiff([[1, 1]]), baseRate, baseDelay);
            whiteBoost = -parseFloat(plainsVariant[2].substring(0,6));
            if(whiteBoost > maxBoost){
                maxBoost = whiteBoost;
                maxColor = "white";
                maxLand = "Plains";
            }
            table.appendChild(tableRow(plainsVariant, "td", ["", "table-num", "table-num"]));
        }
        if(blue > 0){
            let islandVariant = testVariant("+1 Island", createDiff([[2, 1]]), baseRate, baseDelay);
            blueBoost = -parseFloat(islandVariant[2].substring(0,6));
            if(blueBoost > maxBoost){
                maxBoost = blueBoost;
                maxColor = "blue";
                maxLand = "Island";
            }
                table.appendChild(tableRow(islandVariant, "td", ["", "table-num", "table-num"]));
            }
            if(black > 0){
                let swampVariant = testVariant("+1 Swamp", createDiff([[4, 1]]), baseRate, baseDelay);
                blackBoost = -parseFloat(swampVariant[2].substring(0,6));
                if(blackBoost > maxBoost){
                    maxBoost = blackBoost;
                    maxColor = "black";
                    maxLand = "Swamp";
                }
                table.appendChild(tableRow(swampVariant, "td", ["", "table-num", "table-num"]));
            }
            if(red > 0){
                let mountainVariant = testVariant("+1 Mountain", createDiff([[8, 1]]), baseRate, baseDelay);
                redBoost = -parseFloat(mountainVariant[2].substring(0,6));
                if(redBoost > maxBoost){
                    maxBoost = redBoost;
                    maxColor = "red";
                    maxLand = "Mountain";
                }
                table.appendChild(tableRow(mountainVariant, "td", ["", "table-num", "table-num"]));
            }
            if(green > 0){
                let forestVariant = testVariant("+1 Forest", createDiff([[16, 1]]), baseRate, baseDelay);
                greenBoost = -parseFloat(forestVariant[2].substring(0,6));
                if(greenBoost > maxBoost){
                    maxBoost = greenBoost;
                    maxColor = "green";
                    maxLand = "Forest";
                }
                table.appendChild(tableRow(forestVariant, "td", ["", "table-num", "table-num"]));
            }

            // create table for tainted and verge lands if needed
            landCount = landCountBackup;
            if(condLands.length > 0){
                // create html elements
                let condTable = document.getElementById("color-cond-table");
                if(condTable != null){
                    condTable.remove();
                }
                condTable = document.createElement("table");
                cardTable.id = "color-cond-table"
                // shorten names, remove multiples of tainted lands
                let newCondNames = [];
                let newCondList = [];
                for(let i = 0; i < condLands.length; i++){
                    if(!newCondNames.includes(condNames[i].split(" ")[0])){
                        newCondNames.push(condNames[i].split(" ")[0]);
                        newCondList.push(condLands[i][2]);
                    }
                }
                condTable.appendChild(tableRow(["Turn"].concat(newCondNames), "th", ["",""]));
                // process for each turn and each land
                for(let turn = 2; turn < 8; turn++){
                    let myLandCount = landCount;
                    let row = ["Turn " + turn];
                    let landsDrawn = landsAtTurn(turn);
                    rowClass = [""];
                    for(let land = 0; land < newCondList.length; land++){
                        let matches = typeSearch(newCondList[land].replaceAll("a ","").replaceAll("an ","").split(" or "));

                        let avgLands = 0;
                        for(let i = 0; i < landsDrawn.length; i++){
                            avgLands += i * landsDrawn[i];
                        }
                        let odds = 0;
                        // go through the distribution of lands drawn, for each number calculate drawing the relevant lands in those lands
                        //start counting at 2 since 1-landers will fail by default
                        for(let i = 2; i < landsDrawn.length; i++){
                            odds += drawTypeMin(myLandCount - 1, matches, Math.max(0, i - 1), 1) * landsDrawn[i] * i / avgLands;
                        }
                        row.push((odds * 100).toFixed(1) + "%");
                        if(odds >= 0.85){
                            rowClass.push("table-num-green");
                        } else if(odds >= 0.7){
                            rowClass.push("table-num-yellow");
                        } else if(odds >= 0.5){
                            rowClass.push("table-num-orange");
                        } else{
                            rowClass.push("table-num-red");
                        }
                    }
                    condTable.appendChild(tableRow(row, "td", rowClass));
                }
                createTableTab("color-test", "color-analyzer-result-box", ["Overall Performance", "Individual Cards", "Conditional Lands"], [table, cardTable, condTable]);
            }
            else{
                createTableTab("color-test", "color-analyzer-result-box", ["Overall Performance", "Individual Cards"], [table, cardTable]);
            }
            if(result != null){
                result.remove();
            }
            // add text to summarize analysis results
            result = document.createElement("text");
            result.id = "color-analyzer-result";
            result.classList.add("result-text");
            let descriptionText = "<strong>Summary:</strong><br>";
            descriptionText += "Overall, your manabase is ";
            if(baseDelay < 0.25){
                descriptionText += "<strong>very strong</strong>";
            } else if(baseDelay < 0.4){
                descriptionText += "<strong>strong</strong>";
            } else if(baseDelay < 0.6){
                descriptionText += "<strong>functional</strong>";
            } else if(baseDelay < 0.9){
                descriptionText += "<strong>inconsistent</strong>";
            } else {
                descriptionText += "<strong>struggling</strong>";
            }
            descriptionText += ", playing your spells <strong>" + (baseDelay.toFixed(2)) + "</strong> turns late on average.<br>";
            descriptionText += "<strong>" + Math.round(100 * Math.max(genericBoost,0) / maxBoost) + "%</strong> of this delay is due to your land count, while <strong>"
                + Math.round(100 * (1-Math.max(genericBoost,0) / maxBoost)) + "%</strong> is due to your mana colors.<br>";
            descriptionText += "Your weakest color is <strong>" + maxColor + "</strong>.<br>";
            descriptionText += "Adding an extra " + maxLand + " would eliminate <strong>" + Math.round(100 * maxBoost / baseDelay) + "%</strong> of this delay.";
            result.innerHTML = descriptionText;
            document.getElementById("color-analyzer-result-box").appendChild(result);

            endTime = Date.now();
            console.log(`Execution time: ${endTime - startTime} ms`);

            console.log(landTypes);
        }

        // Add an array times a scalar to another array
        function addScaledArr(arr1, arr2, scale){
            for(let i = 0; i < arr1.length; i++){
                arr1[i] += arr2[i] * scale;
            }
        }

        // Find out how long it takes to run out of lands to play
        function lastLand(turns){
            lastLandTurn = new Array(turns+8).fill(0);
            // iterate through the different number of lands in hand after mulligan and their probability
            for(let i = 1; i < mullLands.length; i++){
                addScaledArr(lastLandTurn, rLastLand(i, deckSize-7, landCount - i, 0, turns), mullLands[i]);
            }
            console.log(lastLandTurn);
            console.log(sum(lastLandTurn));
        }

        // Based on a number of lands in opening hand, find the distribution of missed land drops
        function rLastLand(spares, numCards, numLands, turn, max){
            let out = new Array(max+8).fill(0);
            if(spares == 0){
                out[turn] = 1;
            }
            else if(turn >= max){
                out[turn + spares] = 1;
            }
            else{
                addScaledArr(out, rLastLand(spares, numCards-1, numLands-1, turn+1, max), numLands/numCards);
                addScaledArr(out, rLastLand(spares-1, numCards-1, numLands, turn+1, max), (numCards-numLands)/numCards);
            }
            return out;
        }

        // LAND CYCLE FUNCTIONS
        // Calculate how often a fast land enters tapped
        function pTapFast(turns){
            // Enters untapped if you control 2 or fewer other lands
            // If it's drawn before turn 4 (p = 10/n+7), it's untapped
            // If it's drawn on or after turn 4, (p = n-3/n+7), check for the probability that the player has only drawn 2 or fewer other lands by that point.
            let t3Dist = landsAtTurn(3);
            let tapped = 0;
            for(let i = 0; i < t3Dist.length; i++){
                let pTapped = 0;
                if(i >= 3){
                    // Hit first 3 land drops, fast land drawn after turn 3 enters tapped
                    for(let j = 0; j <= turns - 3; j++){
                        let pLand = drawType(deckSize-10, landCount - i, turns - 3, j);
                        pTapped += pLand * j;
                    }
                }
                else{
                    // Missed a land drop, playing lands as they're drawn, fast land drawn after first 3 enters tapped
                    for(let j = 0; j <= turns - 3; j++){
                        let pLand = drawType(deckSize-10, landCount - i, turns - 3, j);
                        pTapped += pLand * Math.max((i+j-3), 0);
                    }
                }
                tapped += pTapped * t3Dist[i];
            }

            let totalLandDist = landsAtTurn(turns);
            let avgLands = 0;
            for(let i = 0; i < totalLandDist.length; i++){
                avgLands += i * totalLandDist[i];
            }
            return tapped / avgLands;
        }

        // Calculate how often a slow land enters tapped
        function pTapSlow(turns){
            if(turns < 3){
                return 1;
            }
            // Enters untapped if you control 2 or more other lands
            // If it's drawn before turn three (p = 9/n+7), check for the probability that the player will draw enough other lands to play first.
            // If it's drawn on or after turn 3 (p = n-2/n+7), check for the probability that the player has drawn two or more other lands by that point.
            let t3Dist = landsAtTurn(3);
            let tapped = 0;
            for(let i = 0; i < mullLands.length; i++){
                let pTapped = 0;
                // 3 or more lands in opening hand: 100% success rate
                // 2 in opening hand: draw one in first 2 turns and we're good, otherwise enters tapped if in first 2
                if(i == 2){
                    for(let j = 0; j <= turns; j++){
                        let pLand = drawType(deckSize-7, landCount - i, turns, j);
                        let pDraw = drawTypeMin(turns, j, 2, 1);
                        pTapped += pLand * 2 * (1 - pDraw);
                    }
                }
                // 1 in opening hand: draw two in first 2 turns and we're good, otherwise enters tapped if in first 2
                else if(i == 1){
                    for(let j = 0; j <= turns; j++){
                        let pLand = drawType(deckSize-7, landCount - i, turns, j);
                        let pDraw = drawTypeMin(turns, j, 2, 2);
                        pTapped += pLand * Math.min((i+j), 2) * (1 - pDraw);
                    }
                }
                // 0 in opening hand: play lands as we draw them, enters tapped if in first 2
                else if(i == 0){
                    for(let j = 0; j <= turns; j++){
                        let pLand = drawType(deckSize-7, landCount - i, turns, j);
                        pTapped += pLand * Math.min((i+j), 2);
                    }
                }
                tapped += pTapped * mullLands[i];
            }

            let totalLandDist = landsAtTurn(turns);
            let avgLands = 0;
            for(let i = 0; i < totalLandDist.length; i++){
                avgLands += i * totalLandDist[i];
            }
            return tapped / avgLands;
        }

        // Calculate how often a check land enters tapped
        function pTapCheck(types, turns){
            if(turns < 2){
                return 1;
            }
            // Enters untapped if you control a card of one of a list of specified types.
            // For this category of check lands, I think it would make sense to model it with the probability that the player draws a card of the accepted types before they have no other lands left
            // The required process will likely look something like this:
            // - check each card in the deck against the list of accepted types and see how many fit one of them. Also note the divide between land and nonland cards
            // - if the types are found on nonland cards, then calculate the probability of of one of them appearing in a random selection of 7 nonland cards
            // - if the types are found on land cards, then find the distribution of how many other lands the player will draw before they are forced to play this one
            // - combine that with the probabilities of one of the accepted land types being among the other lands
            // NOTE: for these lands, the array of accepted types is stored in source.fastInfo
            // most of it includes the exact types that will appear on cards' type lines, but there are a few that just say "legendary creature", and one that just says "legendary green creature"

            // see how many cards in deck are of a type we want
            let relevantCards = typeSearch(types);
            // distinguish between lands and nonland cards
            let typesPlusLand = types.slice();
            typesPlusLand.push("Land");
            let landOverlap = typeSearch(typesPlusLand);
            let relevantNL = landOverlap - landCount;
            let relevantLands = relevantCards - relevantNL;
            let tapped = 0;
            // no relevant cards
            if(relevantLands <= 1 && relevantNL <= 1){
                return 1;
            }
            // relevant cards are all lands
            if(relevantLands > 1 && relevantNL <= 1){
                // based on the distribution of lands played before missing a drop, see if any of the desired cards are among those lands
                for(let i = 0; i < lastLandTurn.length; i++){
                    let pTap = (1-drawTypeMin(landCount - 1, relevantLands, i-1, 1)) * i;
                    for(let j = 1; j <= turns-i; j++){
                        pTap += (1-drawTypeMin(landCount - 1, relevantLands, i+j-1, 1)) * drawTypeMin(deckSize-7-i, landCount-i, turns-i, j);
                    }
                    tapped += pTap * lastLandTurn[i];
                }
            }
            // relevant cards are all nonlands
            else if(relevantLands <= 1 && relevantNL > 1){
                // we will miss a land drop once we draw 7 nonland cards (naively assuming no other card draw)
                tapped = (1 - drawTypeMin(deckSize-landCount, relevantNL, 7, 1));
            }
            // relevant cards are all nonlands
            else if(relevantLands > 1 && relevantNL > 1){
                addError("tap-analyzer-result-box", "You appear to be using check lands in a way we didn't know was possible. Go bother @rudeavocado in the Salubrious Snail discord server so he can add it to this tool");
            }
            // divide by the average number of lands encountered in this case to get the average.
            let totalLandDist = landsAtTurn(turns);
            let avgLands = 0;
            for(let i = 0; i < totalLandDist.length; i++){
                avgLands += i * totalLandDist[i];
            }
            return tapped / avgLands;
        }

        // Calculate how often a tango land enters tapped
        function pTapTango(turns){
            if(turns < 3){
                return 1;
            }
            // Enters untapped if you control 2 or more basic lands
            // like pTapCheck, but you check the probability of 2 basics instead of 1
            let relevantLands = typeSearch(["Basic"]);
            let tapped = 0;
            for(let i = 0; i < lastLandTurn.length; i++){
                let pTap = (1-drawTypeMin(landCount - 1, relevantLands, i-1, 2)) * i;
                for(let j = 1; j <= turns-i; j++){
                    pTap += (1-drawTypeMin(landCount - 1, relevantLands, i+j-1, 2)) * drawTypeMin(deckSize-7-i, landCount-i, turns-i, j);
                }
                tapped += pTap * lastLandTurn[i];
            }

            let totalLandDist = landsAtTurn(turns);
            let avgLands = 0;
            for(let i = 0; i < totalLandDist.length; i++){
                avgLands += i * totalLandDist[i];
            }
            return tapped / avgLands;
        }

        // Calculate how often the monocolored throne of eldraine "three or more" lands enter untapped
        function pTapWilds(types, turns){
            if(turns < 3){
                return 1;
            }
            // For the cycle of "3 or more other [basic type]" lands from eldraine
            // Like pTapCheck, but you use the probability of three instead of 1
            let relevantLands = typeSearch(types);
            let tapped = 0;
            for(let i = 0; i < lastLandTurn.length; i++){
                let pTap = (1-drawTypeMin(landCount - 1, relevantLands, i-1, 3)) * i;
                for(let j = 1; j <= turns-i; j++){
                    pTap += (1-drawTypeMin(landCount - 1, relevantLands, i+j-1, 3)) * drawTypeMin(deckSize-7-i, landCount-i, turns-i, j);
                }
                tapped += pTap * lastLandTurn[i];
            }

            let totalLandDist = landsAtTurn(turns);
            let avgLands = 0;
            for(let i = 0; i < totalLandDist.length; i++){
                avgLands += i * totalLandDist[i];
            }
            return tapped / avgLands;
        }

        // Calculate how often a reveal land enters tapped
        function pTapReveal(types, turns){
            // For the lands that want you to reveal a card of a certain subtype to enter untapped
            //  like pTapCheck, but there's now the possibility of playing the card before you draw the land
            let relevantCards = typeSearch(types);
            let typesPlusLand = types.slice();
            typesPlusLand.push("Land");
            let landOverlap = typeSearch(typesPlusLand);
            let relevantNL = landOverlap - landCount;
            let relevantLands = relevantCards - relevantNL;
            let tapped = 0;
            if(types[0] == "Elemental"){
                // handle weird Flamekin Village Interaction
                relevantLands = 0;
            }
            if(relevantLands == 0 && relevantNL == 0){
                return 1;
            }
            if(relevantLands > 0 && relevantNL == 0){
                for(let i = 0; i < lastLandTurn.length; i++){
                    let pTap = (1-drawTypeMin(landCount - 1, Math.round(relevantLands * 0.8), i-1, 1)) * i;
                    for(let j = 0; j <= turns-i; j++){
                        pTap += j * drawType(deckSize-7-i, landCount-i, turns-i, j);
                    }
                    tapped += pTap * lastLandTurn[i];
                }
                let totalLandDist = landsAtTurn(turns);
                let avgLands = 0;
                for(let i = 0; i < totalLandDist.length; i++){
                    avgLands += i * totalLandDist[i];
                }
                return tapped / avgLands;
            }
            else if(relevantLands == 0 && relevantNL > 0){
                return (1 - drawTypeMin(deckSize-landCount, Math.round(relevantNL * 0.8), 7, 1));
            }
            else if(relevantLands > 0 && relevantNL > 0){
                addError("tap-analyzer-result-box", "You appear to be using reveal lands in a way we didn't know was possible. Go bother @rudeavocado in the Salubrious Snail discord server so he can add it to this tool");
            }
        }

        // Calculate how often a land enters tapped
        function pTap(source, turns){
            if(source.fast == true){
                return 0;
            }
            else if(source.fast == false){
                return 1;
            }
            else if(source.fast == "fast"){
                return pTapFast(turns);
            }
            else if(source.fast == "slow"){
                return pTapSlow(turns);
            }
            else if(source.fast == "check"){
                return pTapCheck(source.fastInfo, turns);
            }
            else if(source.fast == "tango"){
                return pTapTango(turns);
            }
            else if(source.fast == "wilds"){
                return pTapWilds(source.fastInfo, turns);
            }
            else if(source.fast == "reveal"){
                return pTapReveal(source.fastInfo, turns);
            }
            else if(source.fast == "triskaidekadual"){
                return 0.8; //Since this is outside the deck, we just have to use a fixed approximation. I'm thinking it won't happen often though
            }
            else if(source.fast == "unless"){
                addError("tap-analyzer-result-box", "You appear to be using one of those new-fangled land cycles that we haven't even heard of. Go bother @rudeavocado in the Salubrious Sail discord server so he can add it to this tool");
                return 0.5;
            }
            else{
                addError("tap-analyzer-result-box", "Got string \"" + source.fast + "\" and freaked out");
                return 0.5;
            }
        }

        // total up spells and ramp pieces at each mana value, feed them into curve-out simulation
        function findCurveDensity(tapTotal, turns){
            let nonland = 0;
            let curve = new Array(13).fill(0);
            let ramp = new Array(13).fill(0);
            let maxMana = 0;
            for(let i = 0; i < deckList.length; i++){
                if(!deckList[i].card_type.includes("Land")){
                    if(deckList[i].modColorCost.t > 12){
                        curve[12] += deckList[i].count;
                        if(deckList[i].modManaSource.prod > 0){
                            ramp[12] += deckList[i].count;
                        }
                        nonland += deckList[i].count;
                    }
                    else{
                        curve[deckList[i].modColorCost.t] += deckList[i].count;
                        if(deckList[i].modManaSource.prod > 0){
                            ramp[deckList[i].modColorCost.t] += deckList[i].count;
                        }
                        nonland += deckList[i].count;
                    }
                    if(deckList[i].modColorCost.t > maxMana){
                        maxMana = deckList[i].modColorCost.t;
                    }
                }
            }
            curve.length = maxMana + 1;
            calcMullLands();
            let start = Date.now();
            let value = tapTestWrapper(tapTotal, curve, ramp, nonland, turns, 10000);
            console.log("Elapsed time: " + (Date.now()-start) + "ms");
            //console.log(value);
            return(value);
        }

        // wrapper for tapTest
        // run rTapTest() on every combination of tapped and untapped lands that can be drawn and compile results
        function tapTestWrapper(tapTotal, curve, ramp, nonland, maxTurns, span){
            let value = 0;
            let deckLands = [tapTotal, landCount - tapTotal];
            let myMullLands = landsAtTurn(1); // post-mulligan land distribution plus first draw
            iterations = 0;
            let min = 0;
            // iterate through each number of lands that can be drawn
            for(let i = 0; i <= 6; i++){
                // iterate through each number of drawn lands that enter tapped
                for(let j = 0; j <= i && j <= tapTotal; j++){
                    let max = min + span * myMullLands[i] * drawType(landCount, tapTotal, i, j);
                    value += rTapTest(0, [j, i-j], new Array(curve.length), new Array(curve.length), [deckLands[0] - j, deckLands[1] - i + j], nonland, curve.slice(), ramp.slice(), landCount + nonland - 8, 8-i, nonland - 8 + i, maxTurns - 1, min, max);
                    min = max;
                }
            }
            console.log("Iterations: " + iterations);
            return value / span;
        }

        // Given a deck's curve, number of lands, number of tap lands, and the contents of the current hand, calculate how much mana worth of spells the deck will be able to cast within a certain number of turns
        // This explores all the possible options and adds them together based on their relative probabilities
        // In order to save computation, this uses a "wildcard" system for cards that are too expensive to cast, treating them as a single category when drawing cards
        // When more mana becomes available, it uses drawType() to determine how many of the wildcards it can now afford.
        // There is some commented out code to narrate a few of its simulated curve-outs to the console. I'd normally delete, but in this case it's very useful for verifying the simulation when I'm expanding upon it
        function rTapTest(landsDown, handLands, handCurve, handRamp, deckLands, deckNL, deckCurve, deckRamp, deckRemaining, wildcards, wildPicks, turnsRemaining, min, max){
            let span = max - min;
            if(Math.floor(max) == Math.floor(min)){
                return 0;
            }
            if(turnsRemaining == undefined){
                console.log("Uh-oh");
            }
            iterations++;
            // the mana we can work with is based on the number of lands played already plus our ability to play an untapped land
            let mana = landsDown + Math.sign(handLands[1]);
            // If this gives us access to cards that we couldn't previously afford, we need to see how many of them we have
            // This can jump by 2 if we played a tap land last turn and an untapped land this turn
            for(let cmc = 1; cmc <= mana && cmc < handCurve.length; cmc++){
                // if we do not have an entry in the curve array for a mana value, that means that it is included in the wildcards and needs to be brought out
                if(handCurve[cmc] == undefined){
                    // branch based on number of cards of a given cmc drawn
                    let value = 0;
                    // check how many commanders we gain access to
                    let commanders = 0;
                    if(commander1 != undefined && commander1.modColorCost.t == cmc){
                        commanders += 1;
                    }
                    if(commander2 != undefined && commander2.modColorCost.t == cmc){
                        commanders += 1;
                    }
                    if(commander3 != undefined && commander3.modColorCost.t == cmc){
                        commanders += 1;
                    }
                    let newMin = min;
                    // figure out how many wildcards we draw of the relevant cmc
                    for(let i = Math.max(0, deckCurve[cmc] - wildPicks); i <= wildcards && i <= deckCurve[cmc]; i++){
                        let newDeckCurve = deckCurve.slice();
                        newDeckCurve[cmc] -= i;
                        let newHandCurve = handCurve.slice();
                        newHandCurve[cmc] = commanders + i;
                        let sum = 0;
                        let values = new Array(i+1).fill(0);
                        // figure out how many of those wildcards are ramp pieces
                        for(let j = Math.max(0, i + deckRamp[cmc] - deckCurve[cmc]); j <= i && j <= deckRamp[cmc]; j++){
                            let newDeckRamp = deckRamp.slice();
                            newDeckRamp[cmc] -= j;
                            let newHandRamp = handRamp.slice();
                            newHandRamp[cmc] = j;
                            sum += drawType(deckCurve[cmc], deckRamp[cmc], i, j);
                            values[j] = drawType(deckCurve[cmc], deckRamp[cmc], i, j);
                            let newMax = newMin + span * drawType(wildPicks + wildcards, deckCurve[cmc], wildcards, i) * drawType(deckCurve[cmc], deckRamp[cmc], i, j);
                            /*if(Math.floor(newMax/10000) > Math.floor(newMin/10000)){
                                console.log("wildcards for " + cmc + " drops:");
                                console.log(wildcards + " wildcards, " + (commanders + i) + " drawn, " + j + " ramp")
                            }*/
                            value += rTapTest(landsDown, handLands.slice(), newHandCurve.slice(), newHandRamp,
                                deckLands.slice(), deckNL - i, newDeckCurve.slice(), newDeckRamp, deckRemaining,
                                wildcards - i, wildPicks - newDeckCurve[cmc], turnsRemaining, newMin, newMax);
                            newMin = newMax;
                        }
                    }
                    return value;
                }
            }
            /*if(Math.floor(max/10000) > Math.floor(min/10000)){
                console.log(turnsRemaining + " turns remaining");
                console.log("hand lands: " + handLands + ", hand curve: " + handCurve + ", hand ramp: " + handRamp);
                console.log("wildcards: " + wildcards);
                console.log("mana: " + mana);
            }*/
            let check = mana;
            let value = 0;
            /*if(Math.floor(max/10000) > Math.floor(min/10000)){
                console.log(mana + " mana to spend");
            }*/
            let ramp = 0;
            // spend mana as we are able
            for(; check > 0; check--){
                while(handCurve[check] > 0 && mana - check >= 0){
                    handCurve[check] -= 1;
                    /*if(Math.floor(max/10000) > Math.floor(min/10000)){
                        console.log("Played a " + check + " drop");
                    }*/
                    if(handRamp[check] > 0){
                        handRamp[check] -= 1;
                        ramp++;
                        /*if(Math.floor(max/10000) > Math.floor(min/10000)){
                            console.log("Ramped");
                        }*/
                    }
                    mana -= check;
                    value += check; // keep track of mana spent
                    /*if(Math.floor(max/10000) > Math.floor(min/10000)){
                        console.log(mana + " mana remaining");
                    }*/
                }
            }

            // if we used more mana than we had at the start of the turn, then we had to have played an untapped land
            if(value > landsDown){
                handLands[1]--;
                landsDown++;
                /*if(Math.floor(max/10000) > Math.floor(min/10000)){
                    console.log("Played untapped land, we now have " + landsDown + " mana sources");
                }*/
            }
            else if (handLands[0] > 0){ // Otherwise, play a tap land if we have one
                handLands[0]--;
                landsDown++;
                /*if(Math.floor(max/10000) > Math.floor(min/10000)){
                    console.log("Played tapped land, we now have " + landsDown + " mana sources");
                }*/
            }
            else if (handLands[1] > 0){ // Otherwise, play an untapped land
                handLands[1]--;
                landsDown++;
                /*if(Math.floor(max/10000) > Math.floor(min/10000)){
                    console.log("Played untapped land, we now have " + landsDown + " mana sources");
                }*/
            }
            landsDown += ramp;
            value *= (turnsRemaining + 1) * (Math.floor(max) - Math.floor(min));
            // branch based on card drawn next
            if(turnsRemaining > 0){
                // if we can draw lands of either type, draw and calculate the probability
                let newMin = min;
                if(deckLands[0] > 0){
                    let newMax = newMin + span * (deckLands[0] / deckRemaining);
                    /*if(Math.floor(newMax/10000) > Math.floor(newMin/10000)){
                        console.log("drew a tapped land");
                    }*/
                    value += rTapTest(landsDown, [handLands[0] + 1, handLands[1]], handCurve.slice(), handRamp.slice(),
                        [deckLands[0] - 1, deckLands[1]], deckNL, deckCurve.slice(), deckRamp.slice(), deckRemaining - 1,
                        wildcards, wildPicks, turnsRemaining - 1, newMin, newMax);
                    newMin = newMax;
                }
                if(deckLands[1] > 0){
                    let newMax = newMin + span * (deckLands[1] / deckRemaining);
                    /*if(Math.floor(newMax/10000) > Math.floor(newMin/10000)){
                        console.log("drew an untapped land");
                    }*/
                    value += rTapTest(landsDown, [handLands[0], handLands[1] + 1], handCurve.slice(), handRamp.slice(),
                        [deckLands[0], deckLands[1] - 1], deckNL, deckCurve.slice(), deckRamp.slice(), deckRemaining - 1,
                        wildcards, wildPicks, turnsRemaining - 1, newMin, newMax);
                    newMin = newMax;
                }
                // for the cards that are no longer wildcards, we need to test whether they have been drawn individually
                for(let i = 1; handCurve[i] != undefined; i++){
                    if(deckCurve[i] > 0){
                        let newDeckCurve = deckCurve.slice();
                        newDeckCurve[i] -= 1;
                        let newHandCurve = handCurve.slice();
                        newHandCurve[i] += 1;
                        let newDeckRamp = deckRamp.slice();
                        newDeckRamp[i] -= 1;
                        let newHandRamp = handCurve.slice();
                        newHandRamp[i] += 1;
                        let newMax = newMin + span * ((deckCurve[i] - deckRamp[i]) / deckRemaining);
                        /*if(Math.floor(newMax/10000) > Math.floor(newMin/10000)){
                            console.log("drew a " + i + " drop");
                        }*/
                        value += rTapTest(landsDown, handLands.slice(), newHandCurve.slice(), handRamp.slice(),
                            deckLands.slice(), deckNL - 1, newDeckCurve.slice(), deckRamp.slice(), deckRemaining - 1,
                            wildcards, wildPicks, turnsRemaining - 1, newMin, newMax);
                        newMin = newMax;
                        newMax = newMin + span * (deckRamp[i] / deckRemaining);
                        /*if(Math.floor(newMax/10000) > Math.floor(newMin/10000)){
                            console.log("drew a " + i + " drop ramp spell");
                        }*/
                        value += rTapTest(landsDown, handLands.slice(), newHandCurve, newHandRamp,
                            deckLands.slice(), deckNL - 1, newDeckCurve, newDeckRamp, deckRemaining - 1,
                            wildcards, wildPicks, turnsRemaining - 1, newMin, newMax);
                        newMin = newMax;
                    }
                }
                // draw wildcards
                if(wildPicks > 0){
                    let newMax = newMin + span * (wildPicks / deckRemaining);
                    /*if(Math.floor(newMax/10000) > Math.floor(newMin/10000)){
                        console.log("drew a wildcard");
                    }*/
                    value += rTapTest(landsDown, handLands.slice(), handCurve.slice(), handRamp.slice(),
                        deckLands.slice(), deckNL, deckCurve.slice(), deckRamp.slice(), deckRemaining - 1,
                        wildcards + 1, wildPicks - 1, turnsRemaining - 1, newMin, newMax);
                    newMin = newMax;
                }
                /*if(Math.abs(newMin - max) > 0.001 * span){
                    console.log("Something has gone wrong");
                }*/
            }
            //tapAnalDict.set(inputToKey,value);
            return value;
            //}
        }

        // This is the function tied to the compute button for the tap calculator
        //
        function tapTest(){
            var textType = Node.textContent ? 'textContent' : 'innerText',
                result = document.getElementById('tap-analyzer-result'),
                turns = parseFloat(document.getElementById('tap-turns').value) || 5;

            // remove previous errors
            clearError("tap-analyzer-result-box");
            processMods(); // make sure mods are covered

            let tapTotal = 0;
            let untapTotal = 0;
            let landCount = 0;
            // count up lands
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].card_type.includes("Land")){
                    landCount += deckList[i].count;
                }
            }
            // calculate relevant distributions based on land count
            calcMullLands();
            lastLand(turns);
            // remove old table, add new one
            let table = document.getElementById("tap-test-table")
            if(table != null){
                table.remove();
            }
            table = document.createElement("table");
            table.id = "tap-test-table";
            table.appendChild(tableRow(["Land", "Tap Chance"], "th", ["",""]));
            // iterate through lands adding up tap status
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].card_type.includes("Land")){
                    let tap = pTap(deckList[i].modManaSource, turns);
                    tapTotal += deckList[i].count * tap;
                    untapTotal += deckList[i].count * (1 - tap);
                    // add sometimes-tapped lands to table and color code
                    if(tap > 0 && tap < 1){
                        let rowClass = ["", ""];
                        if(tap <= 0.15){
                            rowClass[1] = "table-num-green";
                        } else if(tap <= 0.3){
                            rowClass[1] = "table-num-yellow";
                        } else if(tap <= 0.6){
                            rowClass[1] = "table-num-orange";
                        } else{
                            rowClass[1] = "table-num-red";
                        }
                        table.appendChild(tableRow([deckList[i].name, (tap * 100).toFixed(1) + "%"], "td", rowClass));
                    }
                }
            }
            // run curve-out simulation on variants with no tap lands and one less, compare results
            let actualPerformance = findCurveDensity(Math.round(tapTotal), turns);
            console.log(actualPerformance);
            let oneLessTapPerformance = findCurveDensity(Math.max(Math.round(tapTotal - 1), 0), turns);
            console.log(oneLessTapPerformance);
            let allUntappedPerformance = findCurveDensity(0, turns);
            console.log(allUntappedPerformance);
            if(allUntappedPerformance == 0){
                actualPerformance = 1;
                oneLessTapPerformance = 1;
                allUntappedPerformance = 1;
            }
            result.innerHTML = "Your lands enter tapped <strong>" + (tapTotal * 100 / landCount).toFixed(1) +
                "%</strong> of the time <br>This makes your curve-outs <strong>" + ((1 - (actualPerformance / allUntappedPerformance)) * 100).toFixed(1) +
                "%</strong> less effective <br>This would be a <strong>" + ((1 - (oneLessTapPerformance / allUntappedPerformance)) * 100).toFixed(1) + "%</strong> reduction if you replaced a tap land with an untapped land";
            document.getElementById("tap-analyzer-result-box").appendChild(table);
        }
        // Reveal ignore list with button press
        function toggleIgnore(){
            let ignoreList = document.getElementById("ignore-list");
            ignoreList.hidden = !ignoreList.hidden;
        }
    </script>
    <div class="analyzer" name="deckEntry">
        <p class="title">Deck Loader</p>
        <p class="prompt"> Paste your decklist here (including any commanders or companions)</p>
        <textarea id="decklist" rows="10" cols="50" placeholder="Paste your exported decklist here (format: '1 sol ring' or similar)"></textarea>
        <p class="prompt"> Names of Commanders (if any) </p>
        <input type="text" class="commander-name" id="commander-name-1" placeholder="Commander">
        <div class="commander-weight hidden">
            <br>
            <label for="commander" class="prompt">How important is your commander to your deck?</label>
            <select name="commander" id="cmdr1-weight">
                <option value="10">Just another card (10x weight)</option>
                <option value="20">A nice bonus for a deck that is still functional without it (20x weight)</option>
                <option value="30">A major boost for a deck that would struggle without it (30x weight)</option>
                <option value="50">A critical piece of a deck that would fall flat without it (50x weight)</option>
            </select>
            <br>
        </div>
        <br>
        <input type="text" class="commander-name" id="commander-name-2" placeholder="Partner">
        <div class="commander-weight hidden">
            <br>
            <label for="partner" class="prompt">How important is your partner to your deck?</label>
            <select name="partner" id="cmdr2-weight">
                <option value="10">Just another card (10x weight)</option>
                <option value="20">A nice bonus for a deck that is still functional without it (20x weight)</option>
                <option value="30">A major boost for a deck that would struggle without it (30x weight)</option>
                <option value="50">A critical piece of a deck that would fall flat without it (50x weight)</option>
            </select>
            <br>
        </div>
        <br>
        <input type="text" class="commander-name" id="commander-name-3" placeholder="Companion">
        <div class="commander-weight hidden">
            <br>
            <label for="partner" class="prompt">How important is your companion to your deck?</label>
            <select name="partner" id="cmdr3-weight">
                <option value="10">Just another card (10x weight)</option>
                <option value="20">A nice bonus for a deck that is still functional without it (20x weight)</option>
                <option value="30">A major boost for a deck that would struggle without it (30x weight)</option>
                <option value="50">A critical piece of a deck that would fall flat without it (50x weight)</option>
            </select>
            <br>
        </div>
        <p>Partial matches are accepted ("atraxa", "yuriko", "kenrith", etc.)</p>
        <p>
            <input type="button" value="Load" onclick="loadDict()" id="deck-load-button" style="width: 100px">
        </p>
        <div class="result-box" id="load-result-box">
            <p id='load-result' class="result-text"></p>
        </div>
    </div>
    <div class="analyzer" name="colorCalc">
        <p class="title">Color Analyzer</p>
        <div id="approx-config" hidden>
            <p>It looks like your deck has 5 colors. This makes the analysis more complicated, so it may take a few seconds. These settings can also save time by using imperfect estimates for the most time-consuming cards:</p>
            <p class="prompt"> Estimate cards with <input type="text" id="approx-colors" value="5" style="width: 30px"> or more colors </p>

            <p class="prompt"> Estimation samples </p>
            <input type="text" id="approx-samples" value="100000">
        </div>
        <p class="error-text" name="load-first">
            <input type="button" id="color-compute-button" value="Compute" onclick="colorTest()"> Use the Deck Loader to select a deck
        </p>
        <div class="result-box" id="color-analyzer-result-box">
            <p id='color-analyzer-result' class="result-text"></p>
        </div>
        <br>
    </div>
    <div class="analyzer" name="tapCalc">
        <p class="title">Tap Analyzer</p>
        <p class="prompt"> Include first <input type="text" id="tap-turns" value="7" style="width: 30px"> turns in calculations</p>
        <p class="error-text" name="load-first">
            <input type="button" id="tap-compute-button" value="Compute" onclick="tapTest()"> Use the Deck Loader to select a deck
        </p>
        <div class="result-box" id="tap-analyzer-result-box">
            <p id='tap-analyzer-result' class="result-text"></p>
        </div>
    </div>
    <div class="analyzer" name="modifier">
        <p class="title">Settings & Card Modifications</p>
        <div id="modifications">
            <p class="prompt">Modify cards</p>
            <textarea id="modify" rows="5" cols="50"></textarea>
            <p> If a card name contains "", (), or :, put double quotes around it (i.e. "Summon: Fenrir")<br>
                To remove an auto-generated mod, only remove the part after the ":"<br>
                Modification syntax (insert link later)
            </p>
        </div>
    </div>
</body>
